<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大一大二观影总结</title>
    <link href="/2023/09/01/%E5%A4%A7%E4%B8%80%E5%A4%A7%E4%BA%8C%E8%A7%82%E5%BD%B1%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/01/%E5%A4%A7%E4%B8%80%E5%A4%A7%E4%BA%8C%E8%A7%82%E5%BD%B1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="大一大二观影总结"><a href="#大一大二观影总结" class="headerlink" title="大一大二观影总结"></a>大一大二观影总结</h1><span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>看电影，对我而言是为数不多的爱好之一。电影类型我涉猎较广，偏爱悬疑，推理，警匪，喜欢这类电影结尾时主角揭开所有真相时拍案叫绝的感受。<br>我在大一下加入了学校的电影协会，加入之前我自认为对电影有一定了解，但参加几次观影讨论后发现自己对电影理解之浅薄，从下文将要提到的具体影片就可看出。<br>但我始终认为，电影是一种孤独的艺术，在某个闲暇的傍晚挑一部喜欢的影片静静欣赏，绝对是一种极佳的享受，也是这个快餐时代中越来越难得的体验。观影还是一个时期的记录，回忆一部影片，绝不仅仅想起这片影片本身，还有那个阶段的人，事和思考。<br>我在前段时间才学会了写博客，想在此对我大一下以来观看的57部影片做一简要梳理，主要总结我的主观感受和当时的人与事，以电影为时间线，回顾一下我的大一大二生活。<br>非常欢迎对内容感兴趣的读者和我交流讨论。</p><h2 id="1-熔炉"><a href="#1-熔炉" class="headerlink" title="1. 熔炉"></a>1. 熔炉</h2><p><img src="/img/%E7%86%94%E7%82%89.jpg" alt="熔炉"></p><ul><li>时间：大一下</li><li>评分：8<br>在大一下学期开学回学校的火车上看的，之前听说很有名，豆瓣评分很高，就提前下载了这部影片准备在火车上打发时间。<br>影片内容说实话并没有让我非常印象深刻，可能只有更加了解现实中的一些相关事件才能更好地理解这部影片想要表达的东西。<br>回想起来那次应该是最后一次和高中同学一起回学校了吧，当时因为核酸结果迟迟不出来差点没赶上火车。在火车上我和几个北大的同学漫无目的地聊着，对未来没有任何认知，转眼间已从大一的新生成了大三的本科老人，对未来依然迷茫，却已不再有大一时对校园生活的憧憬与热情。这两年原来的同学也更加忙碌，希望在本科阶段还能再一起多聚聚。</li></ul><h2 id="2-社交网络"><a href="#2-社交网络" class="headerlink" title="2. 社交网络"></a>2. 社交网络</h2><p><img src="/img/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C.jpg" alt="社交网络"></p><ul><li>时间：大一下</li><li>评分：9.5<br>因为好奇扎克伯格的创业史我在大一下学期初的一个周末晚上看了这部电影。<br>电影开头扎克伯格因为nerd被甩，结尾男主鼓起勇气在自己创办的facebook平台上向校园时期的女神发了好友申请。果然爱情才是大多数理工男一生的痛吗hhh<br>当时看完这部电影心情汹涌澎湃，还特意发了一条电影截图的朋友圈，因为被扎克伯格的天才与勇气所打动。</li></ul><h2 id="3-狩猎"><a href="#3-狩猎" class="headerlink" title="3. 狩猎"></a>3. 狩猎</h2><p><img src="/img/%E7%8B%A9%E7%8C%8E.jpg" alt="狩猎"></p><ul><li>时间：大一下</li><li>评分：8.5<br>久闻大名的一部片子，看完后觉得麦叔确实有魅力，影片内容也能反映出现实中的一些社会问题。谣言可以澄清，但偏见难以根除。</li></ul><h2 id="4-恐怖游轮"><a href="#4-恐怖游轮" class="headerlink" title="4. 恐怖游轮"></a>4. 恐怖游轮</h2><p><img src="/img/%E6%81%90%E6%80%96%E6%B8%B8%E8%BD%AE.jpg" alt="恐怖游轮"></p><ul><li>时间：大一下</li><li>评分：10<br>为数不多让我觉得看完直呼过瘾的影片。当时参加学校生权组织的观影活动看的，看完还激动地加了组织者的微信表达了对这部影片的喜爱。<br>十分推荐观看原片。</li></ul><h2 id="5-扫毒"><a href="#5-扫毒" class="headerlink" title="5. 扫毒"></a>5. 扫毒</h2><p><img src="/img/%E6%89%AB%E6%AF%92.jpg" alt="扫毒"></p><ul><li>时间：大一下</li><li>评分：9<br>国产警匪悬疑佳作，刘青云，古天乐，张家辉三男主很有魅力。</li></ul>]]></content>
    
    
    <categories>
      
      <category>电影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.31徐枫老师组会</title>
    <link href="/2023/08/31/8.31%E5%BE%90%E6%9E%AB%E8%80%81%E5%B8%88%E7%BB%84%E4%BC%9A/"/>
    <url>/2023/08/31/8.31%E5%BE%90%E6%9E%AB%E8%80%81%E5%B8%88%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="8-31徐枫老师组会"><a href="#8-31徐枫老师组会" class="headerlink" title="8.31徐枫老师组会"></a>8.31徐枫老师组会</h1><span id="more"></span><h2 id="1-人脸静态重建"><a href="#1-人脸静态重建" class="headerlink" title="1. 人脸静态重建"></a>1. 人脸静态重建</h2><ul><li>neus: Learning Neural Implicit Surfaces by Volume Rendering for Multi-view Reconstruction</li></ul><h2 id="2-逆渲染生成高质量渲染图片"><a href="#2-逆渲染生成高质量渲染图片" class="headerlink" title="2. 逆渲染生成高质量渲染图片"></a>2. 逆渲染生成高质量渲染图片</h2><ul><li>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</li><li>bumpy: adj.（旅程）颠簸的；不平的，多凸块的；经历困难，处境艰难</li><li>envmap:<br>“envmap” 是一个缩写，代表”environment map”（环境贴图）。环境贴图是计算机图形学中的一个重要概念，用于在虚拟场景中模拟真实世界的光照和反射效果，从而增强图像的逼真度。</li><li>detach: vt. 分离；使分开；派遣；使分心</li><li>artifact:<br>  在计算机图形学中，”artifact”（也称为”artefact”，中文译为”伪影”或”伪像”）是指在图像或渲染过程中出现的意外、不自然的图像元素或效果，通常是由于算法、处理步骤或技术限制导致的。这些意外效果可能影响图像的质量、真实感和逼真度。</li><li>Differentiable Rendering:<br>可导渲染（Differentiable Rendering）是一种将深度学习和计算机图形学技术结合的方法，允许通过反向传播技术对渲染过程进行微分，从而在渲染过程中计算梯度，用于优化任务，如图像生成、视觉效果增强和三维场景理解。</li><li>spp: Samples Per Pixel</li></ul><h2 id="3-实时Incremental人体重建"><a href="#3-实时Incremental人体重建" class="headerlink" title="3. 实时Incremental人体重建"></a>3. 实时Incremental人体重建</h2><ul><li>feature volume:<br>特征体（Feature Volume）是一种用于表示三维场景的数据结构，它将场景中的每个点映射到一个特征向量，该特征向量包含该点的特征信息，如颜色、法线、深度、光照等。特征体通常用于实时渲染和重建。</li></ul>]]></content>
    
    
    <categories>
      
      <category>组会笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_the-next-week</title>
    <link href="/2023/08/31/raytracing-the-next-week/"/>
    <url>/2023/08/31/raytracing-the-next-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-the-next-week"><a href="#raytracing-the-next-week" class="headerlink" title="raytracing the next week"></a>raytracing the next week</h1><span id="more"></span><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>add support for textures, volumes, rectangles, instances, lights, and for lots of objects using a BVH</li></ul><h2 id="2-Motion-Blur"><a href="#2-Motion-Blur" class="headerlink" title="2. Motion Blur"></a>2. Motion Blur</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>对于一个真实的相机，快门会保持打开一段时间，这段时间内，相机和世界中的物体可能会发生运动。</p><h3 id="2-1-Introduction-of-SpaceTime-Ray-Tracing"><a href="#2-1-Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="2.1 Introduction of SpaceTime Ray Tracing"></a>2.1 Introduction of SpaceTime Ray Tracing</h3><p>在相机快门打开的某一随机时刻，可以发出一条光线得到一个随机估计。只要我们可以确定在那个时刻物体的位置，我们就可以得到对于这条射线light的准确测量。<br>为了实现这个效果，我们需要存储每个ray的准确时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ray</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ray</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(<span class="hljs-number">0</span>) &#123;&#125; <br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction, <span class="hljs-type">double</span> time) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(time) &#123;&#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">origin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> orig; &#125;<br>    <span class="hljs-function">vec3 <span class="hljs-title">direction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dir; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">time</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123; <span class="hljs-keyword">return</span> tm; &#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orig + t*dir;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    point3 orig;<br>    vec3 dir;<br>    <span class="hljs-type">double</span> tm;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-Managing-Time"><a href="#2-2-Managing-Time" class="headerlink" title="2.2 Managing Time"></a>2.2 Managing Time</h3><p>目前只考虑渲染一帧图片，假设start at time&#x3D;0, end at time&#x3D;1。<br>任务有：</p><ol><li>调整相机使其能在time[0,1]之间随机时刻发出ray</li><li>创建一个可以移动的球体类</li></ol><h3 id="2-3-Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#2-3-Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="2.3 Updating the Camera to Simulate Motion Blur"></a>2.3 Updating the Camera to Simulate Motion Blur</h3><blockquote><p>make constructors complicated if it makes calls simple</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ray <span class="hljs-title">get_ray</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Get a randomly sampled camera ray for the pixel at location i,j.</span><br>    <span class="hljs-keyword">auto</span> pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);<br>    <span class="hljs-keyword">auto</span> pixel_sample = pixel_center + <span class="hljs-built_in">pixel_sample_square</span>();<br><br>    <span class="hljs-keyword">auto</span> ray_origin = (defocus_angle &lt;= <span class="hljs-number">0</span>) ? center : <span class="hljs-built_in">defocus_disk_sample</span>();<br>    <span class="hljs-keyword">auto</span> ray_direction = pixel_sample - ray_origin;<br>    <br>    <span class="hljs-keyword">auto</span> ray_time = <span class="hljs-built_in">random_double</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ray</span>(ray_origin, ray_direction, ray_time);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Adding-Moving-Spheres"><a href="#2-4-Adding-Moving-Spheres" class="headerlink" title="2.4 Adding Moving Spheres"></a>2.4 Adding Moving Spheres</h3><p>对于可运动的球，t&#x3D;0时球心位于center1，t&#x3D;1时球心位于center2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sphere</span> : <span class="hljs-keyword">public</span> hittable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//stationary</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-comment">//moving</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center1, point3 _center2, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center1), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            center_vec = _center2 - _center1;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        vec3 oc = r.<span class="hljs-built_in">origin</span>() - center1;<br>        <span class="hljs-keyword">auto</span> a = r.<span class="hljs-built_in">direction</span>().<span class="hljs-built_in">length_squared</span>();<br>        <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(oc, r.<span class="hljs-built_in">direction</span>());<br>        <span class="hljs-keyword">auto</span> c = oc.<span class="hljs-built_in">length_squared</span>() - radius * radius;<br><br>        <span class="hljs-keyword">auto</span> discriminant = half_b * half_b - a * c;<br>        <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>        <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>        <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>        &#123;<br>            root = (-half_b + sqrtd) / a;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        rec.t = root;<br>        rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>        vec3 outward_normal = (rec.p - center1) / radius;<br>        rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>        rec.mat = mat;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    point3 center1;<br>    <span class="hljs-type">double</span> radius;<br>    shared_ptr&lt;material&gt; mat;<br><br>    <span class="hljs-type">bool</span> is_moving;<br>    vec3 center_vec;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-type">double</span> time)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> center1 + time * center_vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在判断是否击中球体时，需要考虑球体的运动轨迹，即球心的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    point3 center = is_moving? <span class="hljs-built_in">sphere_center</span>(r.<span class="hljs-built_in">time</span>()) : center1;<br>    vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-Tracking-the-Time-of-Ray-Intersection"><a href="#2-5-Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="2.5 Tracking the Time of Ray Intersection"></a>2.5 Tracking the Time of Ray Intersection</h3><p>在计算散射ray时考虑时间属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lambertian</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> scatter_direction = rec.normal + <span class="hljs-built_in">random_unit_vector</span>();<br><br>        <span class="hljs-comment">// Catch degenerate scatter direction</span><br>        <span class="hljs-keyword">if</span> (scatter_direction.<span class="hljs-built_in">near_zero</span>())<br>            scatter_direction = rec.normal;<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">metal</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        vec3 reflected = <span class="hljs-built_in">reflect</span>(<span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>()), rec.normal);<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz*<span class="hljs-built_in">random_in_unit_sphere</span>(), r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dot</span>(scattered.<span class="hljs-built_in">direction</span>(), rec.normal) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dielectric</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, direction, r_in.<span class="hljs-built_in">time</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-6-Putting-Everything-Together"><a href="#2-6-Putting-Everything-Together" class="headerlink" title="2.6 Putting Everything Together"></a>2.6 Putting Everything Together</h3><p>给场景中的部分球体加入运动属性<br>效果图如下：<br><img src="/img/motion_blur.png" alt="motion_blur"></p><h2 id="3-Bounding-Volume-Hierarchies"><a href="#3-Bounding-Volume-Hierarchies" class="headerlink" title="3. Bounding Volume Hierarchies"></a>3. Bounding Volume Hierarchies</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>ray-object的求交是一个ray tracer最主要的时间瓶颈，我们可以按照二分查找的思想把这个过程变成对数时间的search。<br>我们可以对求交模型做一个模拟的sorting，这样每次求交可以变成一个sublinear的search。<br>常见的sorting方法有两种：1.分割空间 2.分割物体，后者在实现上更简单并且对于大多数模型来说速度一样快。</p><h3 id="3-1-The-Key-Idea"><a href="#3-1-The-Key-Idea" class="headerlink" title="3.1 The Key Idea"></a>3.1 The Key Idea</h3><p>包围盒的key idea是找到一个包围所有objects的volumes。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ray hit bounding object：<br>    <span class="hljs-keyword">return</span> 是否hit包围住的物体<br><span class="hljs-keyword">else</span>：<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>a key thing是我们可以把物体分为子集。<br>任何物体都只在一个包围盒中，但包围盒之间可以重叠。</p><h3 id="3-2-Hierarchies-of-Bounding-Volumes"><a href="#3-2-Hierarchies-of-Bounding-Volumes" class="headerlink" title="3.2 Hierarchies of Bounding Volumes"></a>3.2 Hierarchies of Bounding Volumes</h3><p><img src="/img/hierarchy.jpg" alt="hierarchy"><br>内部包围盒之间没有顺序，可能重叠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (hits purple)<br>    hit0 = hits blue enclosed objects<br>    hit1 = hits red enclosed objects<br>    <span class="hljs-keyword">if</span> (hit0 <span class="hljs-keyword">or</span> hit1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> info of closer hit<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Axis-Aligned-Bounding-Boxes-AABBs"><a href="#3-3-Axis-Aligned-Bounding-Boxes-AABBs" class="headerlink" title="3.3 Axis-Aligned Bounding Boxes (AABBs)"></a>3.3 Axis-Aligned Bounding Boxes (AABBs)</h3><p>我们需要找到一种好的划分方式实践以上算法，axis-aligned bounding boxes(AABBs)是一种很好的选择。<br>$$\begin{align*}<br>    x_0 &#x3D; A_x + t_0b_x \newline<br>    t_0 &#x3D; \frac{x_0 - A_x}{b_x} \newline<br>    t_1 &#x3D; \frac{x_1 - A_x}{b_x}<br>\end{align*}$$<br><img src="/img/aabb.jpg" alt="aabb"><br>将上式转换为hit监测：如果hit则两个1D的t区间有交集。</p><h3 id="3-4-Ray-Intersection-with-an-AABB"><a href="#3-4-Ray-Intersection-with-an-AABB" class="headerlink" title="3.4 Ray Intersection with an AABB"></a>3.4 Ray Intersection with an AABB</h3><p>若使用IEEE浮点数，0有正负号。当$b_x&#x3D;0$时，若$A$不在$x_0,x_1$之间，则$t_{x0}, t_{x1}$将同时为$+\infty$或$-\infty$。<br>所以可以使用min和max得到正确的解<br>$$\begin{align*}<br>    t_{x0} &#x3D; min(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})\newline<br>    t_{x1} &#x3D; max(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})<br>\end{align*}$$<br>在实现overlap函数时，如果有NaNs会报错，因此我们需要给包围盒加一点padding。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">interval</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> max - min;<br>    &#125;<br><br>    <span class="hljs-function">interval <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">double</span> delta)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> padding = delta/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">interval</span>(min - padding, max + padding);<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AABB_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AABB_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    interval x, y, z;<br><br>    <span class="hljs-built_in">aabb</span>() &#123;&#125; <span class="hljs-comment">// The default AABB is empty, since intervals are empty by default.</span><br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> interval&amp; ix, <span class="hljs-type">const</span> interval&amp; iy, <span class="hljs-type">const</span> interval&amp; iz)<br>      : <span class="hljs-built_in">x</span>(ix), <span class="hljs-built_in">y</span>(iy), <span class="hljs-built_in">z</span>(iz) &#123; &#125;<br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> point3&amp; a, <span class="hljs-type">const</span> point3&amp; b) &#123;<br>        <span class="hljs-comment">// Treat the two points a and b as extrema for the bounding box, so we don&#x27;t require a</span><br>        <span class="hljs-comment">// particular minimum/maximum coordinate order.</span><br>        x = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]));<br>        y = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]));<br>        z = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> interval&amp; <span class="hljs-title">axis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> z;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> t0 = <span class="hljs-built_in">fmin</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-keyword">auto</span> t1 = <span class="hljs-built_in">fmax</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-type">ray_t</span>.min = <span class="hljs-built_in">fmax</span>(t0, <span class="hljs-type">ray_t</span>.min);<br>            <span class="hljs-type">ray_t</span>.max = <span class="hljs-built_in">fmin</span>(t1, <span class="hljs-type">ray_t</span>.max);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-5-An-Optimized-AABB-Hit-Method"><a href="#3-5-An-Optimized-AABB-Hit-Method" class="headerlink" title="3.5 An Optimized AABB Hit Method"></a>3.5 An Optimized AABB Hit Method</h3><p>Andrew Kensler做了很多实验发现下面这个版本的代码在某些编译器上性能极好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> invD = <span class="hljs-number">1</span> / r.<span class="hljs-built_in">direction</span>()[a];<br>            <span class="hljs-keyword">auto</span> orig = r.<span class="hljs-built_in">origin</span>()[a];<br><br>            <span class="hljs-keyword">auto</span> t0 = (<span class="hljs-built_in">axis</span>(a).min - orig) * invD;<br>            <span class="hljs-keyword">auto</span> t1 = (<span class="hljs-built_in">axis</span>(a).max - orig) * invD;<br><br>            <span class="hljs-keyword">if</span> (invD &lt; <span class="hljs-number">0</span>)<br>                std::<span class="hljs-built_in">swap</span>(t0, t1);<br><br>            <span class="hljs-keyword">if</span> (t0 &gt; <span class="hljs-type">ray_t</span>.min) <span class="hljs-type">ray_t</span>.min = t0;<br>            <span class="hljs-keyword">if</span> (t1 &lt; <span class="hljs-type">ray_t</span>.max) <span class="hljs-type">ray_t</span>.max = t1;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-6-Constructing-Bounding-Boxes-for-Hittables"><a href="#3-6-Constructing-Bounding-Boxes-for-Hittables" class="headerlink" title="3.6 Constructing Bounding Boxes for Hittables"></a>3.6 Constructing Bounding Boxes for Hittables</h3><p>为objects添加包围盒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于静止球体，可以直接根据center和radius计算；对于运动球体，可以根据radius和center1，center2分别计算两个包围盒，再求这两个包围盒的并集。</p><h3 id="3-7-Creating-Bounding-Boxes-of-Lists-of-Objects"><a href="#3-7-Creating-Bounding-Boxes-of-Lists-of-Objects" class="headerlink" title="3.7 Creating Bounding Boxes of Lists of Objects"></a>3.7 Creating Bounding Boxes of Lists of Objects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable_list</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;<br><br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123;<br>        objects.<span class="hljs-built_in">push_back</span>(object);<br>        bbox = <span class="hljs-built_in">aabb</span>(bbox, object-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">double</span> ray_tmin, <span class="hljs-type">double</span> ray_tmax, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    aabb bbox;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-8-The-BVH-Node-Class"><a href="#3-8-The-BVH-Node-Class" class="headerlink" title="3.8 The BVH Node Class"></a>3.8 The BVH Node Class</h3><p>A BVH是一个容器，like lists of hittables，可以respond to “whether hit” query<br>一种设计思路是划分两个类，分别为node和tree；一种是将root视为node，每次对node的包围盒进行hit判断，如果hit则对node的两个子节点进行hit判断。本书采用后者实现思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BVH_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BVH_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable_list.h&quot;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> hittable_list&amp; list) : <span class="hljs-built_in">bvh_node</span>(list.objects, <span class="hljs-number">0</span>, list.objects.<span class="hljs-built_in">size</span>()) &#123;&#125;<br><br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-comment">// To be implemented later.</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!box.<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">bool</span> hit_left = left-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>, rec);<br>        <span class="hljs-type">bool</span> hit_right = right-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-built_in">interval</span>(<span class="hljs-type">ray_t</span>.min, hit_left ? rec.t : <span class="hljs-type">ray_t</span>.max), rec);<br><br>        <span class="hljs-keyword">return</span> hit_left || hit_right;<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;hittable&gt; left;<br>    shared_ptr&lt;hittable&gt; right;<br>    aabb bbox;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-9-Splitting-BVH-Volumes"><a href="#3-9-Splitting-BVH-Volumes" class="headerlink" title="3.9 Splitting BVH Volumes"></a>3.9 Splitting BVH Volumes</h3><blockquote><p>The most complicated part of any efficiency structure, including the BVH, is building it.The most complicated part of any efficiency structure, including the BVH, is building it.</p></blockquote><p>build一个BVH的过程如下：</p><ol><li>randomly choose an axis</li><li>sort the primitives (using std::sort)</li><li>put half in each subtree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-keyword">auto</span> objects = src_objects; <span class="hljs-comment">// Create a modifiable array of the source scene objects</span><br><br>        <span class="hljs-type">int</span> axis = <span class="hljs-built_in">random_int</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">auto</span> comparator = (axis == <span class="hljs-number">0</span>) ? box_x_compare<br>                        : (axis == <span class="hljs-number">1</span>) ? box_y_compare<br>                                      : box_z_compare;<br><br>        <span class="hljs-type">size_t</span> object_span = end - start;<br><br>        <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">1</span>) &#123;<br>            left = right = objects[start];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">comparator</span>(objects[start], objects[start+<span class="hljs-number">1</span>])) &#123;<br>                left = objects[start];<br>                right = objects[start+<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = objects[start+<span class="hljs-number">1</span>];<br>                right = objects[start];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>() + start, objects.<span class="hljs-built_in">begin</span>() + end, comparator);<br><br>            <span class="hljs-keyword">auto</span> mid = start + object_span/<span class="hljs-number">2</span>;<br>            left = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid);<br>            right = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end);<br>        &#125;<br><br>        bbox = <span class="hljs-built_in">aabb</span>(left-&gt;<span class="hljs-built_in">bounding_box</span>(), right-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>当objects中有无限大平面时需要检查是否有包围盒，因为无限大平面无包围盒。</li></ol><h3 id="3-10-The-Box-Comparison-Functions"><a href="#3-10-The-Box-Comparison-Functions" class="headerlink" title="3.10 The Box Comparison Functions"></a>3.10 The Box Comparison Functions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  ...<br>  <span class="hljs-keyword">private</span>:<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_compare</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b, <span class="hljs-type">int</span> axis_index</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min &lt; b-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_x_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_y_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_z_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>经测试，渲染下图无包围盒层次结构所用时间为67.4132s，有包围盒层次结构所用时间为17.7801s。<br><img src="/img/motion_blur.png" alt="image"></p><h2 id="4-Texture-Mapping"><a href="#4-Texture-Mapping" class="headerlink" title="4.Texture Mapping"></a>4.Texture Mapping</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><ul><li>texture: the effect(color, shininess, bump geometry, …)</li><li>mapping: mapping one space onto another in the mathematical sense</li></ul><h3 id="4-1-Constant-Color-Texture"><a href="#4-1-Constant-Color-Texture" class="headerlink" title="4.1 Constant Color Texture"></a>4.1 Constant Color Texture</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TEXTURE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEXTURE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">texture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">texture</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3 &amp;p)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">solid_color</span> : <span class="hljs-keyword">public</span> texture<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">solid_color</span>(color c) : <span class="hljs-built_in">color_value</span>(c) &#123;&#125;<br><br>    <span class="hljs-built_in">solid_color</span>(<span class="hljs-type">double</span> red, <span class="hljs-type">double</span> green, <span class="hljs-type">double</span> blue) : <span class="hljs-built_in">solid_color</span>(<span class="hljs-built_in">color</span>(red, green, blue)) &#123;&#125;<br><br>    <span class="hljs-function">color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3 &amp;p)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> color_value;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    color color_value;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>同时在hittable类中增加double变量u,v</p><h3 id="4-2-Solid-Textures-A-Checker-Texture"><a href="#4-2-Solid-Textures-A-Checker-Texture" class="headerlink" title="4.2 Solid Textures: A Checker Texture"></a>4.2 Solid Textures: A Checker Texture</h3><p>solid texture仅取决于3D空间中每个点的位置，它给空间中所有点上色，而不是特定的物体。<br>the texture value忽略u,v，只取决于p。</p>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_in-one-week</title>
    <link href="/2023/08/30/raytracing-in-one-week/"/>
    <url>/2023/08/30/raytracing-in-one-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-in-one-week"><a href="#raytracing-in-one-week" class="headerlink" title="raytracing in one week"></a>raytracing in one week</h1><span id="more"></span><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h2><p>笔者在大二下学期上了《计算机图形学基础》这门课，由于时间匆忙+能力有限，在完成光线追踪渲染器时疏漏了很多细节。关于真实感渲染器的实现有很多不错的课程资料，比如Games101，smallpt，Ray Tracing in One Weekend等等，笔者计划在大三上学期开学前抽出一周时间，完成Ray Tracing in One Weekend的学习，以此来巩固自己的图形学基础知识，实现一个质量更高的光线追踪渲染器。</p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>get cool images with no API</li><li>the architecture will be good for extending to a more full-featured ray tracer</li></ul><h2 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2. Output an Image"></a>2. Output an Image</h2>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
