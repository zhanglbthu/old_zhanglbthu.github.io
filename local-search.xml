<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>raytracing_the-next-week</title>
    <link href="/2023/08/31/raytracing-the-next-week/"/>
    <url>/2023/08/31/raytracing-the-next-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-the-next-week"><a href="#raytracing-the-next-week" class="headerlink" title="raytracing the next week"></a>raytracing the next week</h1><span id="more"></span><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>add support for textures, volumes, rectangles, instances, lights, and for lots of objects using a BVH</li></ul><h2 id="2-Motion-Blur"><a href="#2-Motion-Blur" class="headerlink" title="2. Motion Blur"></a>2. Motion Blur</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>对于一个真实的相机，快门会保持打开一段时间，这段时间内，相机和世界中的物体可能会发生运动。</p><h3 id="2-1-Introduction-of-SpaceTime-Ray-Tracing"><a href="#2-1-Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="2.1 Introduction of SpaceTime Ray Tracing"></a>2.1 Introduction of SpaceTime Ray Tracing</h3><p>在相机快门打开的某一随机时刻，可以发出一条光线得到一个随机估计。只要我们可以确定在那个时刻物体的位置，我们就可以得到对于这条射线light的准确测量。<br>为了实现这个效果，我们需要存储每个ray的准确时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ray</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ray</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(<span class="hljs-number">0</span>) &#123;&#125; <br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction, <span class="hljs-type">double</span> time) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(time) &#123;&#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">origin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> orig; &#125;<br>    <span class="hljs-function">vec3 <span class="hljs-title">direction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dir; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">time</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123; <span class="hljs-keyword">return</span> tm; &#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orig + t*dir;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    point3 orig;<br>    vec3 dir;<br>    <span class="hljs-type">double</span> tm;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-Managing-Time"><a href="#2-2-Managing-Time" class="headerlink" title="2.2 Managing Time"></a>2.2 Managing Time</h3><p>目前只考虑渲染一帧图片，假设start at time&#x3D;0, end at time&#x3D;1。<br>任务有：</p><ol><li>调整相机使其能在time[0,1]之间随机时刻发出ray</li><li>创建一个可以移动的球体类</li></ol><h3 id="2-3-Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#2-3-Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="2.3 Updating the Camera to Simulate Motion Blur"></a>2.3 Updating the Camera to Simulate Motion Blur</h3><blockquote><p>make constructors complicated if it makes calls simple</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ray <span class="hljs-title">get_ray</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Get a randomly sampled camera ray for the pixel at location i,j.</span><br>    <span class="hljs-keyword">auto</span> pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);<br>    <span class="hljs-keyword">auto</span> pixel_sample = pixel_center + <span class="hljs-built_in">pixel_sample_square</span>();<br><br>    <span class="hljs-keyword">auto</span> ray_origin = (defocus_angle &lt;= <span class="hljs-number">0</span>) ? center : <span class="hljs-built_in">defocus_disk_sample</span>();<br>    <span class="hljs-keyword">auto</span> ray_direction = pixel_sample - ray_origin;<br>    <br>    <span class="hljs-keyword">auto</span> ray_time = <span class="hljs-built_in">random_double</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ray</span>(ray_origin, ray_direction, ray_time);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Adding-Moving-Spheres"><a href="#2-4-Adding-Moving-Spheres" class="headerlink" title="2.4 Adding Moving Spheres"></a>2.4 Adding Moving Spheres</h3><p>对于可运动的球，t&#x3D;0时球心位于center1，t&#x3D;1时球心位于center2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sphere</span> : <span class="hljs-keyword">public</span> hittable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//stationary</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-comment">//moving</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center1, point3 _center2, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center1), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            center_vec = _center2 - _center1;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        vec3 oc = r.<span class="hljs-built_in">origin</span>() - center1;<br>        <span class="hljs-keyword">auto</span> a = r.<span class="hljs-built_in">direction</span>().<span class="hljs-built_in">length_squared</span>();<br>        <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(oc, r.<span class="hljs-built_in">direction</span>());<br>        <span class="hljs-keyword">auto</span> c = oc.<span class="hljs-built_in">length_squared</span>() - radius * radius;<br><br>        <span class="hljs-keyword">auto</span> discriminant = half_b * half_b - a * c;<br>        <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>        <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>        <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>        &#123;<br>            root = (-half_b + sqrtd) / a;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        rec.t = root;<br>        rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>        vec3 outward_normal = (rec.p - center1) / radius;<br>        rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>        rec.mat = mat;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    point3 center1;<br>    <span class="hljs-type">double</span> radius;<br>    shared_ptr&lt;material&gt; mat;<br><br>    <span class="hljs-type">bool</span> is_moving;<br>    vec3 center_vec;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-type">double</span> time)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> center1 + time * center_vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在判断是否击中球体时，需要考虑球体的运动轨迹，即球心的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    point3 center = is_moving? <span class="hljs-built_in">sphere_center</span>(r.<span class="hljs-built_in">time</span>()) : center1;<br>    vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-Tracking-the-Time-of-Ray-Intersection"><a href="#2-5-Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="2.5 Tracking the Time of Ray Intersection"></a>2.5 Tracking the Time of Ray Intersection</h3><p>在计算散射ray时考虑时间属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lambertian</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> scatter_direction = rec.normal + <span class="hljs-built_in">random_unit_vector</span>();<br><br>        <span class="hljs-comment">// Catch degenerate scatter direction</span><br>        <span class="hljs-keyword">if</span> (scatter_direction.<span class="hljs-built_in">near_zero</span>())<br>            scatter_direction = rec.normal;<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">metal</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        vec3 reflected = <span class="hljs-built_in">reflect</span>(<span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>()), rec.normal);<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz*<span class="hljs-built_in">random_in_unit_sphere</span>(), r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dot</span>(scattered.<span class="hljs-built_in">direction</span>(), rec.normal) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dielectric</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, direction, r_in.<span class="hljs-built_in">time</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-6-Putting-Everything-Together"><a href="#2-6-Putting-Everything-Together" class="headerlink" title="2.6 Putting Everything Together"></a>2.6 Putting Everything Together</h3><p>给场景中的部分球体加入运动属性<br>效果图如下：<br><img src="/img/motion_blur.png" alt="motion_blur"></p><h2 id="3-Bounding-Volume-Hierarchies"><a href="#3-Bounding-Volume-Hierarchies" class="headerlink" title="3. Bounding Volume Hierarchies"></a>3. Bounding Volume Hierarchies</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>ray-object的求交是一个ray tracer最主要的时间瓶颈，我们可以按照二分查找的思想把这个过程变成对数时间的search。<br>我们可以对求交模型做一个模拟的sorting，这样每次求交可以变成一个sublinear的search。<br>常见的sorting方法有两种：1.分割空间 2.分割物体，后者在实现上更简单并且对于大多数模型来说速度一样快。</p><h3 id="3-1-The-Key-Idea"><a href="#3-1-The-Key-Idea" class="headerlink" title="3.1 The Key Idea"></a>3.1 The Key Idea</h3><p>包围盒的key idea是找到一个包围所有objects的volumes。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ray hit bounding object：<br>    <span class="hljs-keyword">return</span> 是否hit包围住的物体<br><span class="hljs-keyword">else</span>：<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>a key thing是我们可以把物体分为子集。<br>任何物体都只在一个包围盒中，但包围盒之间可以重叠。</p><h3 id="3-2-Hierarchies-of-Bounding-Volumes"><a href="#3-2-Hierarchies-of-Bounding-Volumes" class="headerlink" title="3.2 Hierarchies of Bounding Volumes"></a>3.2 Hierarchies of Bounding Volumes</h3><p><img src="/img/hierarchy.jpg" alt="hierarchy"><br>内部包围盒之间没有顺序，可能重叠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (hits purple)<br>    hit0 = hits blue enclosed objects<br>    hit1 = hits red enclosed objects<br>    <span class="hljs-keyword">if</span> (hit0 <span class="hljs-keyword">or</span> hit1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> info of closer hit<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Axis-Aligned-Bounding-Boxes-AABBs"><a href="#3-3-Axis-Aligned-Bounding-Boxes-AABBs" class="headerlink" title="3.3 Axis-Aligned Bounding Boxes (AABBs)"></a>3.3 Axis-Aligned Bounding Boxes (AABBs)</h3><p>我们需要找到一种好的划分方式实践以上算法，axis-aligned bounding boxes(AABBs)是一种很好的选择。<br>$$<br>    x_0 &#x3D; A_x + t_0b_x \<br>    t_0 &#x3D; \frac{x_0 - A_x}{b_x}\<br>    t_1 &#x3D; \frac{x_1 - A_x}{b_x}<br>$$<br><img src="/img/aabb.jpg" alt="aabb"><br>将上式转换为hit监测：如果hit则两个1D的t区间有交集。</p><h3 id="3-4-Ray-Intersection-with-an-AABB"><a href="#3-4-Ray-Intersection-with-an-AABB" class="headerlink" title="3.4 Ray Intersection with an AABB"></a>3.4 Ray Intersection with an AABB</h3><p>若使用IEEE浮点数，0有正负号。当$b_x&#x3D;0$时，若$A$不在$x_0,x_1$之间，则$t_{x0}, t_{x1}$将同时为$+\infty$或$-\infty$。<br>所以可以使用min和max得到正确的解<br>$$<br>    t_{x0} &#x3D; min(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})\<br>    t_{x1} &#x3D; max(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})<br>$$<br>在实现overlap函数时，如果有NaNs会报错，因此我们需要给包围盒加一点padding。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">interval</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> max - min;<br>    &#125;<br><br>    <span class="hljs-function">interval <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">double</span> delta)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> padding = delta/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">interval</span>(min - padding, max + padding);<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AABB_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AABB_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    interval x, y, z;<br><br>    <span class="hljs-built_in">aabb</span>() &#123;&#125; <span class="hljs-comment">// The default AABB is empty, since intervals are empty by default.</span><br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> interval&amp; ix, <span class="hljs-type">const</span> interval&amp; iy, <span class="hljs-type">const</span> interval&amp; iz)<br>      : <span class="hljs-built_in">x</span>(ix), <span class="hljs-built_in">y</span>(iy), <span class="hljs-built_in">z</span>(iz) &#123; &#125;<br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> point3&amp; a, <span class="hljs-type">const</span> point3&amp; b) &#123;<br>        <span class="hljs-comment">// Treat the two points a and b as extrema for the bounding box, so we don&#x27;t require a</span><br>        <span class="hljs-comment">// particular minimum/maximum coordinate order.</span><br>        x = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]));<br>        y = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]));<br>        z = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> interval&amp; <span class="hljs-title">axis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> z;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> t0 = <span class="hljs-built_in">fmin</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-keyword">auto</span> t1 = <span class="hljs-built_in">fmax</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-type">ray_t</span>.min = <span class="hljs-built_in">fmax</span>(t0, <span class="hljs-type">ray_t</span>.min);<br>            <span class="hljs-type">ray_t</span>.max = <span class="hljs-built_in">fmin</span>(t1, <span class="hljs-type">ray_t</span>.max);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-5-An-Optimized-AABB-Hit-Method"><a href="#3-5-An-Optimized-AABB-Hit-Method" class="headerlink" title="3.5 An Optimized AABB Hit Method"></a>3.5 An Optimized AABB Hit Method</h3><p>Andrew Kensler做了很多实验发现下面这个版本的代码在某些编译器上性能极好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> invD = <span class="hljs-number">1</span> / r.<span class="hljs-built_in">direction</span>()[a];<br>            <span class="hljs-keyword">auto</span> orig = r.<span class="hljs-built_in">origin</span>()[a];<br><br>            <span class="hljs-keyword">auto</span> t0 = (<span class="hljs-built_in">axis</span>(a).min - orig) * invD;<br>            <span class="hljs-keyword">auto</span> t1 = (<span class="hljs-built_in">axis</span>(a).max - orig) * invD;<br><br>            <span class="hljs-keyword">if</span> (invD &lt; <span class="hljs-number">0</span>)<br>                std::<span class="hljs-built_in">swap</span>(t0, t1);<br><br>            <span class="hljs-keyword">if</span> (t0 &gt; <span class="hljs-type">ray_t</span>.min) <span class="hljs-type">ray_t</span>.min = t0;<br>            <span class="hljs-keyword">if</span> (t1 &lt; <span class="hljs-type">ray_t</span>.max) <span class="hljs-type">ray_t</span>.max = t1;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-6-Constructing-Bounding-Boxes-for-Hittables"><a href="#3-6-Constructing-Bounding-Boxes-for-Hittables" class="headerlink" title="3.6 Constructing Bounding Boxes for Hittables"></a>3.6 Constructing Bounding Boxes for Hittables</h3><p>为objects添加包围盒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于静止球体，可以直接根据center和radius计算；对于运动球体，可以根据radius和center1，center2分别计算两个包围盒，再求这两个包围盒的并集。</p><h3 id="3-7-Creating-Bounding-Boxes-of-Lists-of-Objects"><a href="#3-7-Creating-Bounding-Boxes-of-Lists-of-Objects" class="headerlink" title="3.7 Creating Bounding Boxes of Lists of Objects"></a>3.7 Creating Bounding Boxes of Lists of Objects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable_list</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;<br><br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123;<br>        objects.<span class="hljs-built_in">push_back</span>(object);<br>        bbox = <span class="hljs-built_in">aabb</span>(bbox, object-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">double</span> ray_tmin, <span class="hljs-type">double</span> ray_tmax, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    aabb bbox;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-8-The-BVH-Node-Class"><a href="#3-8-The-BVH-Node-Class" class="headerlink" title="3.8 The BVH Node Class"></a>3.8 The BVH Node Class</h3><p>A BVH是一个容器，like lists of hittables，可以respond to “whether hit” query<br>一种设计思路是划分两个类，分别为node和tree；一种是将root视为node，每次对node的包围盒进行hit判断，如果hit则对node的两个子节点进行hit判断。本书采用后者实现思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BVH_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BVH_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable_list.h&quot;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> hittable_list&amp; list) : <span class="hljs-built_in">bvh_node</span>(list.objects, <span class="hljs-number">0</span>, list.objects.<span class="hljs-built_in">size</span>()) &#123;&#125;<br><br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-comment">// To be implemented later.</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!box.<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">bool</span> hit_left = left-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>, rec);<br>        <span class="hljs-type">bool</span> hit_right = right-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-built_in">interval</span>(<span class="hljs-type">ray_t</span>.min, hit_left ? rec.t : <span class="hljs-type">ray_t</span>.max), rec);<br><br>        <span class="hljs-keyword">return</span> hit_left || hit_right;<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;hittable&gt; left;<br>    shared_ptr&lt;hittable&gt; right;<br>    aabb bbox;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-9-Splitting-BVH-Volumes"><a href="#3-9-Splitting-BVH-Volumes" class="headerlink" title="3.9 Splitting BVH Volumes"></a>3.9 Splitting BVH Volumes</h3><blockquote><p>The most complicated part of any efficiency structure, including the BVH, is building it.The most complicated part of any efficiency structure, including the BVH, is building it.</p></blockquote><p>build一个BVH的过程如下：</p><ol><li>randomly choose an axis</li><li>sort the primitives (using std::sort)</li><li>put half in each subtree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-keyword">auto</span> objects = src_objects; <span class="hljs-comment">// Create a modifiable array of the source scene objects</span><br><br>        <span class="hljs-type">int</span> axis = <span class="hljs-built_in">random_int</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">auto</span> comparator = (axis == <span class="hljs-number">0</span>) ? box_x_compare<br>                        : (axis == <span class="hljs-number">1</span>) ? box_y_compare<br>                                      : box_z_compare;<br><br>        <span class="hljs-type">size_t</span> object_span = end - start;<br><br>        <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">1</span>) &#123;<br>            left = right = objects[start];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">comparator</span>(objects[start], objects[start+<span class="hljs-number">1</span>])) &#123;<br>                left = objects[start];<br>                right = objects[start+<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = objects[start+<span class="hljs-number">1</span>];<br>                right = objects[start];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>() + start, objects.<span class="hljs-built_in">begin</span>() + end, comparator);<br><br>            <span class="hljs-keyword">auto</span> mid = start + object_span/<span class="hljs-number">2</span>;<br>            left = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid);<br>            right = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end);<br>        &#125;<br><br>        bbox = <span class="hljs-built_in">aabb</span>(left-&gt;<span class="hljs-built_in">bounding_box</span>(), right-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>当objects中有无限大平面时需要检查是否有包围盒，因为无限大平面无包围盒。</li></ol><h3 id="3-10-The-Box-Comparison-Functions"><a href="#3-10-The-Box-Comparison-Functions" class="headerlink" title="3.10 The Box Comparison Functions"></a>3.10 The Box Comparison Functions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  ...<br>  <span class="hljs-keyword">private</span>:<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_compare</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b, <span class="hljs-type">int</span> axis_index</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min &lt; b-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_x_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_y_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_z_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_in-one-week</title>
    <link href="/2023/08/30/raytracing-in-one-week/"/>
    <url>/2023/08/30/raytracing-in-one-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-in-one-week"><a href="#raytracing-in-one-week" class="headerlink" title="raytracing in one week"></a>raytracing in one week</h1><span id="more"></span><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h2><p>笔者在大二下学期上了《计算机图形学基础》这门课，由于时间匆忙+能力有限，在完成光线追踪渲染器时疏漏了很多细节。关于真实感渲染器的实现有很多不错的课程资料，比如Games101，smallpt，Ray Tracing in One Weekend等等，笔者计划在大三上学期开学前抽出一周时间，完成Ray Tracing in One Weekend的学习，以此来巩固自己的图形学基础知识，实现一个质量更高的光线追踪渲染器。</p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>get cool images with no API</li><li>the architecture will be good for extending to a more full-featured ray tracer</li></ul><h2 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2. Output an Image"></a>2. Output an Image</h2>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
