<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BDPT</title>
    <link href="/2023/09/10/BDPT/"/>
    <url>/2023/09/10/BDPT/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rendering</title>
    <link href="/2023/09/07/rendering/"/>
    <url>/2023/09/07/rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="What-is-rendering"><a href="#What-is-rendering" class="headerlink" title="What is rendering?"></a>What is rendering?</h1><h2 id="正向渲染"><a href="#正向渲染" class="headerlink" title="正向渲染"></a>正向渲染</h2><h3 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h3><p>可以实现全局光照</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><h2 id="逆向渲染"><a href="#逆向渲染" class="headerlink" title="逆向渲染"></a>逆向渲染</h2><p>可以应用于三维重建，新视角合成……</p><h3 id="可微渲染"><a href="#可微渲染" class="headerlink" title="可微渲染"></a>可微渲染</h3><h3 id="神经渲染"><a href="#神经渲染" class="headerlink" title="神经渲染"></a>神经渲染</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>raytracing-rest-of-your-life</title>
    <link href="/2023/09/07/rol/"/>
    <url>/2023/09/07/rol/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-The-Rest-Of-Your-Life"><a href="#Ray-Tracing-The-Rest-Of-Your-Life" class="headerlink" title="Ray Tracing: The Rest Of Your Life"></a>Ray Tracing: The Rest Of Your Life</h1><span id="more"></span><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1.Overview"></a>1.Overview</h2><h2 id="2-A-Simple-Monte-Carlo-Program"><a href="#2-A-Simple-Monte-Carlo-Program" class="headerlink" title="2.A Simple Monte Carlo Program"></a>2.A Simple Monte Carlo Program</h2><p>有两类随机算法：Monte Carlo和Las Vegas</p><ul><li>Las Vegas：总是给出正确的结果，但是运行时间是随机的(快速排序)</li><li>Monte Carlo：总是在有限时间内给出结果，但是结果可能是错误的</li></ul><p>Monte Carlo算法给出一种统计评估，运行时间越久，估计结果越准确</p><h3 id="2-1-Estimating-Pi"><a href="#2-1-Estimating-Pi" class="headerlink" title="2.1 Estimating Pi"></a>2.1 Estimating Pi</h3><p>在[-1,1]x[-1,1]的正方形内随机生成N个点，计算落在圆内的点的个数，用这个比例乘以4就是$\pi$的估计值</p><h3 id="2-2-Showing-Convergence"><a href="#2-2-Showing-Convergence" class="headerlink" title="2.2 Showing Convergence"></a>2.2 Showing Convergence</h3><p>把程序改成永久运行，我们可以很快地接近$\pi$，然后慢慢地逼近它</p><h3 id="2-3-Stratified-Samples-Jittering"><a href="#2-3-Stratified-Samples-Jittering" class="headerlink" title="2.3 Stratified Samples (Jittering)"></a>2.3 Stratified Samples (Jittering)</h3><p>Diminishing Returns</p><blockquote><p>递减收益：在投入更多的劳动力或资本后，产出增长的速度会逐渐减缓，最终无法与投入成正比。</p></blockquote><p>这是Monte Carlo算法最差的情况，每一次采样的帮助都不如上一次的。我们可以通过分层采样减缓这种情况<br>我们在网格中每个格子内选取一个样本而不是随机采样<br><img src="/img/stratify.jpg" alt="sampling areas"><br>分层方法不仅效果更好，收敛速度也更快。然而，这种优势会随着问题的维数增加而减小<br>Curse of Dimensionality</p><blockquote><p>维数灾难：在多维系统分析中由于可用数据的稀疏性而引起的问题。<br>· The curse of dimensionality makes it difficult to analyze multidimensional systems due to the sparse nature of the available data.<br>维数灾难使得由于可用数据的稀疏性，分析多维系统变得困难。</p></blockquote><p>光线追踪就是一个高维的算法，每次反射新增两个维度$\theta,\phi$<br>作为过渡，我们将对每个像素周围的采样位置进行分层<br><img src="/img/riw/nos.png" alt="no stratified samples"><br><img src="/img/riw/withs.png" alt="stratified samples"><br>分层采样之后，在盒子和平面边缘有更锋利的对比，在频率变化较高的地区，这种影响将更为明显</p><h2 id="3-One-Dimensional-Monte-Carlo-Integration"><a href="#3-One-Dimensional-Monte-Carlo-Integration" class="headerlink" title="3. One Dimensional Monte Carlo Integration"></a>3. One Dimensional Monte Carlo Integration</h2><h3 id="3-1-Expected-Value"><a href="#3-1-Expected-Value" class="headerlink" title="3.1 Expected Value"></a>3.1 Expected Value</h3><p>$Y$的期望<br>$$\begin{aligned}<br>avarage(Y) &amp;&#x3D; E[Y] &#x3D; \frac{1}{N} \sum_{i&#x3D;0}^{N-1} y_i \newline<br>&amp;&#x3D; \frac{1}{N} \sum_{i&#x3D;0}^{N-1} f(x_i) \newline<br>&amp;&#x3D; E[F(X)]<br>\end{aligned}$$<br>如果$x_i$在区间$[a,b]$上连续，则$E[F(X)]$近似于连续函数$f(x’)$在区间$a&lt;x’&lt;b$上的平均值<br>$$\begin{aligned}<br>E[f(x’)|a&lt;x’&lt;b] &amp;\approx E[F(X) | X &#x3D; {x_i|a&lt;x_i&lt;b}] \newline<br>&amp;\approx E[y &#x3D; {f(x_i)|a&lt;x_i&lt;b}] \newline<br>&amp;\approx \frac{1}{N} \sum_{i&#x3D;0}^{N-1} f(x_i)<br>\end{aligned}$$<br>当$N\rightarrow\infty$时<br>$$\begin{aligned}<br>E[f(x’)|a&lt;x’&lt;b] &#x3D; lim_{N\rightarrow\infty} \frac{1}{N} \sum_{i&#x3D;0}^{N-1} f(x_i)<br>\end{aligned}$$<br>当采样点的数量足够多时，我们可以用输出结果的平均值来近似函数的期望值，这就是Monte Carlo算法<br>除了随机采样，我们可以选择平均划分的空间点<br>$$\begin{aligned}<br>x_i &#x3D; a+i\Delta x\newline<br>\Delta x &#x3D; \frac{b-a}{N}<br>\end{aligned}$$<br>期望值如下<br>$$\begin{aligned}<br>E[f(x’)|a&lt;x’&lt;b] &amp;\approx \frac{1}{N} \sum_{i&#x3D;0}^{N-1} f(x_i) \newline<br>&amp;&#x3D; \frac{\Delta x}{b-a} \sum_{i&#x3D;0}^{N-1} f(x_i) \newline<br>&amp;&#x3D; \frac{1}{b-a} \sum_{i&#x3D;0}^{N-1} f(x_i) \Delta x \newline<br>&amp;\approx \frac{1}{b-a} \int_a^b f(x) dx(N\rightarrow\infty)\newline<br>&amp;&#x3D; \frac{1}{b-a} area(f(x),a,b)<br>\end{aligned}$$<br>积分和蒙特卡洛方法都可以求特定区间的平均值<br>积分是求解无穷多个无限小区间的和的平均值，蒙特卡罗算法将通过求解区间内不断增加的随机抽样点的和来近似相同的平均值</p><h3 id="3-2-Integrating-x²-example"><a href="#3-2-Integrating-x²-example" class="headerlink" title="3.2 Integrating x²(example)"></a>3.2 Integrating x²(example)</h3><h3 id="3-3-Density-Functions"><a href="#3-3-Density-Functions" class="headerlink" title="3.3 Density Functions"></a>3.3 Density Functions</h3><p>之前的ray_color算法存在一个主要的问题，较小的光源会产生非常大的噪声，这是因为我们的采样方法不能经常对这些光源进行采样<br>光源只有当光线射向它们时才被采样，但这对于面积较小的光源和较远的光源是比较困难的<br>对于任一给定的光线，我们经常从相机开始跟踪，通过场景，终止于光源；但我们可以尝试从光源开始跟踪，通过场景，终止于相机<br>对于后者中的任意一条光线，它会从光源出发，在多次弹射中被不同表面反射而变暗或上色，最终到达相机<br>如果我们强制使其弹射向相机，那么会损失中间多次弹射的过程<br>这种方法可以解决光源较小&#x2F;远时一个像素亮但周围像素暗的问题，但会导致所有像素都比较亮<br>我们可以通过降低特定采样点的权重调整过采样来解决这个问题<br>首先需要了解密度函数<br>Density Function<br><img src="/img/riw/histogram.jpg" alt="histogram"><br>$$\begin{aligned}<br>Probability\ of\ bin\ i\ &amp;&#x3D;\ Density\ of\ Bin\ i\newline &amp;&#x3D; \frac{Number\ of\ items\ in\ Bin\ i}{Number\ of\ items\ total} \newline<br>\end{aligned}$$<br>PDF(Probability Density Function)是一个连续函数，可以对其进行积分来确定结果落在某个区间的概率</p><h3 id="3-4-Constructing-a-PDF"><a href="#3-4-Constructing-a-PDF" class="headerlink" title="3.4 Constructing a PDF"></a>3.4 Constructing a PDF</h3><h3 id="3-5-Choosing-our-Samples"><a href="#3-5-Choosing-our-Samples" class="headerlink" title="3.5 Choosing our Samples"></a>3.5 Choosing our Samples</h3><p>Metropolis-Hastings Algorithm</p><blockquote><p>In statistics and statistical physics, the Metropolis–Hastings algorithm is a Markov chain Monte Carlo (MCMC) method for obtaining a sequence of random samples from a probability distribution from which direct sampling is difficult. This sequence can be used to approximate the distribution (e.g. to generate a histogram) or to compute an integral (e.g. an expected value). Metropolis–Hastings and other MCMC algorithms are generally used for sampling from multi-dimensional distributions, especially when the number of dimensions is high. For single-dimensional distributions, there are usually other methods (e.g. adaptive rejection sampling) that can directly return independent samples from the distribution, and these are free from the problem of autocorrelated samples that is inherent in MCMC methods.</p></blockquote><h3 id="3-6-Approximating-Distributions"><a href="#3-6-Approximating-Distributions" class="headerlink" title="3.6 Approximating Distributions"></a>3.6 Approximating Distributions</h3><h3 id="3-7-Importance-Sampling"><a href="#3-7-Importance-Sampling" class="headerlink" title="3.7 Importance Sampling"></a>3.7 Importance Sampling</h3><h2 id="4-Monte-Carlo-Integration-on-the-Sphere-of-Directions"><a href="#4-Monte-Carlo-Integration-on-the-Sphere-of-Directions" class="headerlink" title="4. Monte Carlo Integration on the Sphere of Directions"></a>4. Monte Carlo Integration on the Sphere of Directions</h2><p><img src="/img/riw/sphere.jpg" alt="sphere"></p><h2 id="5-Light-Scattering"><a href="#5-Light-Scattering" class="headerlink" title="5. Light Scattering"></a>5. Light Scattering</h2><h3 id="5-1-Albedo"><a href="#5-1-Albedo" class="headerlink" title="5.1 Albedo"></a>5.1 Albedo</h3>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neural Layered BRDFs</title>
    <link href="/2023/09/07/nlb/"/>
    <url>/2023/09/07/nlb/</url>
    
    <content type="html"><![CDATA[<h1 id="Neural-Layered-BRDFs"><a href="#Neural-Layered-BRDFs" class="headerlink" title="Neural Layered BRDFs"></a>Neural Layered BRDFs</h1><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>许多常见的材质具有多层结构。用蒙特卡洛方法模拟光线传播可以得到准确的结果，但会导致high variance and cost<br>我们建议在神经空间中处理分层结构，通过提出的表示神经网络将brdf压缩成latent codes，然后通过layering network对这些latent vector进行学习后的分层操作</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>多层材质的BRDFs比单层材质的要复杂很多，因为光线可能会在离开表面之前在不同层之间弹射多次<br>蒙特卡洛方法较为准确但会导致high variance and cost，其他方法要么不够准确要么需要大量的内存占用<br>近年来神经网络极大地减少了内存占用，成功地使SVBRDF和BTF在渲染中可用，但它们都没有考虑多层材质<br>我们建议用一个潜在空间表示分析和测量的brdf，然后用分层网络在潜在向量之间进行分层操作</p><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><ul><li>Neural based SVBRDF&#x2F;BTF&#x2F;BRDF compression<ul><li>specialized methods：一个神经网络仅表示一种材质&#x2F;BRDF，渲染结果质量很高，但存储开销很大，很难操作</li><li>generalized methods：以降低质量为代价，提出了一种统一的模型。但与我们方法相比它们在高镜面材质上的表现不好</li></ul></li><li>BRDF layering operations<ul><li><blockquote><p>BRDF（Bidirectional Reflectance Distribution Function）图层操作是在计算机图形学中用于模拟复杂材质外观的技术之一。这些操作允许开发人员将多个BRDF（通常是不同的材质属性或表面层）组合在一起，以模拟复杂材质的效果，例如具有镶嵌的镜面反射、漫反射和透射的材质。</p></blockquote></li><li>蒙特卡洛方法可以产生高质量的结果，我们把它作为ground truth，但random walks会产生噪声。我们的分层结果和基于蒙特卡洛的方法非常接近，但避免了昂贵的随机漫步和额外的方差(噪声)</li></ul></li></ul><h2 id="NEURAL-BRDF-REPRESENTATION-AND-LAYERING"><a href="#NEURAL-BRDF-REPRESENTATION-AND-LAYERING" class="headerlink" title="NEURAL BRDF REPRESENTATION AND LAYERING"></a>NEURAL BRDF REPRESENTATION AND LAYERING</h2><h3 id="Overview-and-formulation"><a href="#Overview-and-formulation" class="headerlink" title="Overview and formulation"></a>Overview and formulation</h3><p>$\textbf{Representation}$<br>首先将任意BRDF压缩成一个紧凑的神经表示<br>$$\begin{aligned}<br>f(\omega_i,\omega_o)\xrightarrow{N_{rep}}V_f<br>\end{aligned}$$<br>$V_f$:latent vector，$N_{rep}$:representation projecting operator<br>$\textbf{Layering}$<br>当BRDFs被表示为latent vectors后，我们把他们当作运算对象，提供一个作用于它们的分层操作<br>$$\begin{aligned}<br>{V_{top},V_{bottom},A,\sigma_T}\xrightarrow{N_{layering}}V_{layered}<br>\end{aligned}$$<br>$V_{top},V_{bottom}$:依次表示上下层BRDF的latent vector<br>$A,\sigma_T$:两层之间参与介质的single scattering albedo和extinction coefficient</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>正向渲染</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-Noise</title>
    <link href="/2023/09/06/noise/"/>
    <url>/2023/09/06/noise/</url>
    
    <content type="html"><![CDATA[<h1 id="pbrt10-6-Noise"><a href="#pbrt10-6-Noise" class="headerlink" title="pbrt10.6 Noise"></a>pbrt10.6 Noise</h1><h2 id="10-6-1-Perlin-Noise"><a href="#10-6-1-Perlin-Noise" class="headerlink" title="10.6.1 Perlin Noise"></a>10.6.1 Perlin Noise</h2><ul><li>在$(x,y,z)$整数格点值为0</li><li>它的变化来自于每个格点上的梯度向量，这些梯度向量决定了格点间如何平滑地插值<br><img src="/img/pbrt/perlin.png" alt="perlin noise"><br><img src="/img/pbrt/perlin_ball.png" alt="ball with perlin noise"><br>实现主要三步：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Noise</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1. compute noise cell coordinates and offsets</span><br>    <span class="hljs-comment">//2. compute gradient weights</span><br>    <span class="hljs-comment">//3. compute trilinear interpolation of weights</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
      <tag>pbrt</tag>
      
      <tag>noise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-Introduction</title>
    <link href="/2023/09/06/pbrt/"/>
    <url>/2023/09/06/pbrt/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="1-1-Literate-Programming"><a href="#1-1-Literate-Programming" class="headerlink" title="1.1 Literate Programming"></a>1.1 Literate Programming</h2><ul><li><a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>发明的一套新的编程方法</li><li>混合文档格式语言和编程语言</li><li>features<ul><li>mix prose with source code</li><li>provides mechanisms for presenting the program code to the reader</li></ul></li></ul><h2 id="1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm"><a href="#1-2-Photorealistic-Rendering-and-the-Ray-Tracing-Algorithm" class="headerlink" title="1.2 Photorealistic Rendering and the Ray-Tracing Algorithm"></a>1.2 Photorealistic Rendering and the Ray-Tracing Algorithm</h2><h3 id="1-2-1-Cameras"><a href="#1-2-1-Cameras" class="headerlink" title="1.2.1 Cameras"></a>1.2.1 Cameras</h3><p><img src="/img/pinhole.svg" alt="camera"><br>当我们模拟针孔相机时，通常把film平面对称放到针孔的前面，这样针孔可以被视为人的眼睛<br><img src="/img/front.svg" alt="camera"></p><h3 id="1-2-2-Ray–Object-Intersections"><a href="#1-2-2-Ray–Object-Intersections" class="headerlink" title="1.2.2 Ray–Object Intersections"></a>1.2.2 Ray–Object Intersections</h3><h3 id="1-2-3-Light-Distribution"><a href="#1-2-3-Light-Distribution" class="headerlink" title="1.2.3 Light Distribution"></a>1.2.3 Light Distribution</h3><p><img src="/img/pbrt/light.svg" alt="light"><br>如果一块表面$dA$倾斜了$\theta$角度，则differential irradiance为<br>$$<br>dE &#x3D; \frac{\Phi cos\theta}{4\pi r^2}<br>$$</p><h3 id="1-2-4-Visibility"><a href="#1-2-4-Visibility" class="headerlink" title="1.2.4 Visibility"></a>1.2.4 Visibility</h3><p><img src="/img/pbrt/vis.svg" alt="visibility"></p><h3 id="1-2-5-Surface-Scattering"><a href="#1-2-5-Surface-Scattering" class="headerlink" title="1.2.5 Surface Scattering"></a>1.2.5 Surface Scattering</h3><p>BRDF(Bidirectional Reflectance Distribution Function)描述了表面的反射特性，表示从$\omega_i$到$\omega_o$有多少能量被反射出去，写作$f_r(p,\omega_o,\omega_i)$<br>BTRF(Bidirectional Transmittance Distribution Function)推广到透射光<br>BSDF(Bidirectional Scattering Distribution Function)描述一般的散射<br>BSSDF(Bidirectional Scattering Surface Reflectance Distribution Function)建模光线从表面一点进入，然后从该表面不同点离开的散射</p><h3 id="1-2-6-Indirect-Light-Transport"><a href="#1-2-6-Indirect-Light-Transport" class="headerlink" title="1.2.6 Indirect Light Transport"></a>1.2.6 Indirect Light Transport</h3><p>rendering equation:<br>$$<br>L_o(p,\omega_o) &#x3D; L_e(p,\omega_o) + \int_{S^2}f_r(p,\omega_o,\omega_i)L_i(p,\omega_i)|cos\theta_i|d\omega_i<br>$$<br>除了一些非常简单的场景，解析这个积分是不可能的，所以我们需要用简化假设或者数值方法来近似</p><h3 id="1-2-7-Ray-Propagation"><a href="#1-2-7-Ray-Propagation" class="headerlink" title="1.2.7 Ray Propagation"></a>1.2.7 Ray Propagation</h3><p>我们目前假设光在真空中传播，在路径中没有减弱，但真实世界中类似烟雾，灰尘等中间介质的出现会打破这一假设<br>中间介质会对光线的传播产生两种可能的影响：</p><ul><li>通过吸收或散射光减弱光的传播</li><li>中间介质自发光或反射其他方向的光可能会增强射线上的光</li></ul>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
      <tag>physically-based rendering</tag>
      
      <tag>pbrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Differentiable Rendering using RGBXY Derivatives and Optimal Transport</title>
    <link href="/2023/09/04/differentiable-rendering/"/>
    <url>/2023/09/04/differentiable-rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="Differentiable-Rendering-using-RGBXY-Derivatives-and-Optimal-Transport"><a href="#Differentiable-Rendering-using-RGBXY-Derivatives-and-Optimal-Transport" class="headerlink" title="Differentiable Rendering using RGBXY Derivatives and Optimal Transport"></a>Differentiable Rendering using RGBXY Derivatives and Optimal Transport</h1><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Traditional differentiable rendering approaches are usually hard to converge in inverse rendering optimizations, especially when initial and target object locations are not so close<br>We present a novel differentiable rendering method to address this problem</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>正向渲染</tag>
      
      <tag>可导渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neural Global Illumination:Interactive Indirect Illumination Prediction under Dynamic Area Lights</title>
    <link href="/2023/09/04/neural-global/"/>
    <url>/2023/09/04/neural-global/</url>
    
    <content type="html"><![CDATA[<h1 id="Neural-Global-Illumination-Interactive-Indirect-Illumination-Prediction-under-Dynamic-Area-Lights"><a href="#Neural-Global-Illumination-Interactive-Indirect-Illumination-Prediction-under-Dynamic-Area-Lights" class="headerlink" title="Neural Global Illumination:Interactive Indirect Illumination Prediction under Dynamic Area Lights"></a>Neural Global Illumination:Interactive Indirect Illumination Prediction under Dynamic Area Lights</h1><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We propose neural global illumination, a novel method for fast rendering full global illumination in static scenes with dynamic viewpoint and area lighting<br>The key idea of our method is to utilize a deep rendering network to model the complex mapping from each shading point to global illumination</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Classic offline rendering methods such as path tracing and photon mapping can achieve photorealistic rendering quality. However, these methods are time-consuming and take minutes or even hours to render a single noise-free frame which makes them not suitable for interactive applications<br>We propose neural global illumination for generating rich global illumination effects in static scenes under dynamic area light sources<br>The motivation of our method is to reduce the gap between offline and interactive methods by applying deep learning to the global illumination problem<br>The key idea of our method is to utilize a deep neural network to represent the complex mapping from input scene information (including attributes of each shading point, the viewpoint, and the incident lighting information) to global illumination</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>正向渲染</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CG</title>
    <link href="/2023/09/04/CG%E7%94%B3%E8%AF%B7/"/>
    <url>/2023/09/04/CG%E7%94%B3%E8%AF%B7/</url>
    
    <content type="html"><![CDATA[<p>cg申请资料</p><span id="more"></span><h1 id="CG"><a href="#CG" class="headerlink" title="CG"></a>CG</h1><h2 id="申请经验分享"><a href="#申请经验分享" class="headerlink" title="申请经验分享"></a>申请经验分享</h2><h3 id="知乎转载"><a href="#知乎转载" class="headerlink" title="知乎转载"></a>知乎转载</h3><p><a href="https://zhuanlan.zhihu.com/p/475751340">2022 Fall CS PhD申请总结</a></p><h2 id="CSRankings选校"><a href="#CSRankings选校" class="headerlink" title="CSRankings选校"></a>CSRankings选校</h2><h3 id="Stanford-University"><a href="#Stanford-University" class="headerlink" title="Stanford University"></a>Stanford University</h3><ul><li>Gordon Wetzstein<ul><li><a href="https://stanford.edu/~gordonwz/">Gordon Wetzstein</a></li><li>next-generation imaging, wearable computing, and neural rendering systems</li></ul></li><li>Doug James<ul><li><a href="https://profiles.stanford.edu/doug-james">Doug James</a></li><li>computer graphics, computer sound, physically based modeling and animation, and reduced-order physics models</li></ul></li><li>Pat Hanrahan<ul><li><a href="https://graphics.stanford.edu/~hanrahan/">Pat Hanrahan</a></li><li>visualization, graphics systems and architectures, rendering algorithms</li></ul></li><li>Kayvon Fatahalian<ul><li><a href="http://graphics.stanford.edu/~kayvonf/">Kayvon Fatahalian</a></li><li>High-performance simulation of virtual environments for “AI training”, New applications based on analyzing big video data, Human-in-the-loop, interactive AI</li></ul></li></ul><h3 id="Massachusetts-Institute-of-Technology"><a href="#Massachusetts-Institute-of-Technology" class="headerlink" title="Massachusetts Institute of Technology"></a>Massachusetts Institute of Technology</h3><ul><li>Frédo Durand<ul><li><a href="https://people.csail.mit.edu/fredo/">Frédo Durand</a></li><li>synthetic image generation, computational photography</li></ul></li><li>Jonathan Ragan-Kelley<ul><li><a href="https://people.csail.mit.edu/jrk/">Jonathan Ragan-Kelley</a></li><li>high-efficiency computer graphics, at the intersection of graphics with systems, architecture, and compilers</li></ul></li></ul><h3 id="Univ-of-California-Santa-Barbara"><a href="#Univ-of-California-Santa-Barbara" class="headerlink" title="Univ. of California - Santa Barbara"></a>Univ. of California - Santa Barbara</h3><ul><li>Lingqi Yan<ul><li><a href="https://sites.cs.ucsb.edu/~lingqi/">Lingqi Yan</a></li><li>physically-based &#x2F; image-based rendering, real-time ray tracing and realistic appearance modeling &#x2F; acquisition</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>申请</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学选校 申请经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unbiased Caustics Rendering Guided by Representative Specular Paths</title>
    <link href="/2023/09/01/Paths/"/>
    <url>/2023/09/01/Paths/</url>
    
    <content type="html"><![CDATA[<h1 id="Unbiased-Caustics-Rendering-Guided-by-Representative-Specular-Paths"><a href="#Unbiased-Caustics-Rendering-Guided-by-Representative-Specular-Paths" class="headerlink" title="Unbiased Caustics Rendering Guided by Representative Specular Paths"></a>Unbiased Caustics Rendering Guided by Representative Specular Paths</h1><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Rendering caustics in computer graphics is still challenging: they correspond to high luminous intensity focused over a small area. Finding the paths that contribute to this small area is difficult<br>We present a novel path guiding approach to enable reliable rendering of caustics</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Our key idea is to use representative specular paths as a proxy to guide sampling for rendering caustics, so that the difficult paths can be found quickly and exhaustively<br>Contributions:</p><ul><li>a path guiding approach via representative specular paths</li><li>a relaxed path cut approach to represent light transport among glossy surfaces</li><li>an SG-based representation to approximate the contribution from a representative specular path</li><li>a spatial reuse strategy combined with a parallax-aware representation to improve the performance</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>正向渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大一大二观影总结</title>
    <link href="/2023/09/01/%E5%A4%A7%E4%B8%80%E5%A4%A7%E4%BA%8C%E8%A7%82%E5%BD%B1%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/01/%E5%A4%A7%E4%B8%80%E5%A4%A7%E4%BA%8C%E8%A7%82%E5%BD%B1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="大一大二观影总结"><a href="#大一大二观影总结" class="headerlink" title="大一大二观影总结"></a>大一大二观影总结</h1><span id="more"></span><h2 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>看电影，对我而言是为数不多的爱好之一。电影类型我涉猎较广，偏爱悬疑，推理，警匪，喜欢这类电影结尾时主角揭开所有真相时拍案叫绝的感受。<br>我在大一下加入了学校的电影协会，加入之前我自认为对电影有一定了解，但参加几次观影讨论后发现自己对电影理解之浅薄，从下文将要提到的具体影片就可看出。<br>但我始终认为，电影是一种孤独的艺术，在某个闲暇的傍晚挑一部喜欢的影片静静欣赏，绝对是一种极佳的享受，也是这个快餐时代中越来越难得的体验。观影还是一个时期的记录，回忆一部影片，绝不仅仅想起这片影片本身，还有那个阶段的人，事和思考。<br>我在前段时间才学会了写博客，想在此对我大一下以来观看的57部影片做一简要梳理，主要总结我的主观感受和当时的人与事，以电影为时间线，回顾一下我的大一大二生活。<br>非常欢迎对内容感兴趣的读者和我交流讨论。</p><h3 id="1-熔炉"><a href="#1-熔炉" class="headerlink" title="1. 熔炉"></a>1. 熔炉</h3><p><img src="/img/%E7%86%94%E7%82%89.jpg" alt="熔炉"></p><ul><li>评分：8<br>在大一下学期开学回学校的火车上看的，之前听说很有名，豆瓣评分很高，就提前下载了这部影片准备在火车上打发时间。<br>影片内容说实话并没有让我非常印象深刻，可能只有更加了解现实中的一些相关事件才能更好地理解这部影片想要表达的东西。<br>回想起来那次应该是最后一次和高中同学一起回学校了吧，当时因为核酸结果迟迟不出来差点没赶上火车。在火车上我和几个北大的同学漫无目的地聊着，对未来没有任何认知，转眼间已从大一的新生成了大三的本科老人，对未来依然迷茫，却已不再有大一时对校园生活的憧憬与热情。这两年原来的同学也更加忙碌，希望在本科阶段还能再一起多聚聚。</li></ul><h3 id="2-社交网络"><a href="#2-社交网络" class="headerlink" title="2. 社交网络"></a>2. 社交网络</h3><p><img src="/img/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C.jpg" alt="社交网络"></p><ul><li>评分：9.5<br>因为好奇扎克伯格的创业史我在大一下学期初的一个周末晚上看了这部电影。<br>电影开头扎克伯格因为nerd被甩，结尾男主鼓起勇气在自己创办的facebook平台上向校园时期的女神发了好友申请。果然爱情才是大多数理工男一生的痛吗hhh<br>当时看完这部电影心情汹涌澎湃，还特意发了一条电影截图的朋友圈，因为被扎克伯格的天才与勇气所打动。</li></ul><h3 id="3-狩猎"><a href="#3-狩猎" class="headerlink" title="3. 狩猎"></a>3. 狩猎</h3><p><img src="/img/%E7%8B%A9%E7%8C%8E.jpg" alt="狩猎"></p><ul><li>评分：8.5<br>久闻大名的一部片子，看完后觉得麦叔确实有魅力，影片内容也能反映出现实中的一些社会问题。谣言可以澄清，但偏见难以根除。</li></ul><h3 id="4-恐怖游轮"><a href="#4-恐怖游轮" class="headerlink" title="4. 恐怖游轮"></a>4. 恐怖游轮</h3><p><img src="/img/%E6%81%90%E6%80%96%E6%B8%B8%E8%BD%AE.jpg" alt="恐怖游轮"></p><ul><li>评分：10<br>为数不多让我觉得看完直呼过瘾的影片。当时参加学校生权组织的观影活动看的，看完还激动地加了组织者的微信表达了对这部影片的喜爱。<br>十分推荐观看原片。</li></ul><h3 id="5-扫毒"><a href="#5-扫毒" class="headerlink" title="5. 扫毒"></a>5. 扫毒</h3><p><img src="/img/%E6%89%AB%E6%AF%92.jpg" alt="扫毒"></p><ul><li>评分：9<br>国产警匪悬疑佳作，刘青云，古天乐，张家辉三男主影帝飙戏。<br>导演陈木胜的另一部作品《怒火重案》也十分不错。</li></ul><h3 id="6-蝴蝶效应"><a href="#6-蝴蝶效应" class="headerlink" title="6. 蝴蝶效应"></a>6. 蝴蝶效应</h3><p><img src="/img/%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94.jpg" alt="蝴蝶效应"></p><ul><li>评分：9.6<br>难得的悬疑佳作，男主不断回到过去，试图拯救自己爱的人，但每一次都以意外告终。<br>哪怕重新来过，仍无法达到完美；不如接受缺憾，珍惜现在。</li></ul><h3 id="7-让子弹飞"><a href="#7-让子弹飞" class="headerlink" title="7. 让子弹飞"></a>7. 让子弹飞</h3><p><img src="/img/%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E.jpg" alt="让子弹飞"></p><ul><li>评分：8<br>民间封神的一部电影，人物，台词，情节被很多人解读剖析。<br>然而第一遍观看未能有过多感触。</li></ul><h3 id="8-杀人回忆"><a href="#8-杀人回忆" class="headerlink" title="8. 杀人回忆"></a>8. 杀人回忆</h3><p><img src="/img/%E6%9D%80%E4%BA%BA%E5%9B%9E%E5%BF%86.jpg" alt="杀人回忆"></p><ul><li>评分：8<br>改编自韩国真实事件，现实中的犯罪嫌疑人仍未被抓获。</li></ul><h3 id="9-绿皮书"><a href="#9-绿皮书" class="headerlink" title="9. 绿皮书"></a>9. 绿皮书</h3><p><img src="/img/%E7%BB%BF%E7%9A%AE%E4%B9%A6.jpg" alt="绿皮书"></p><ul><li>评分：8.6<br>大学第一个五一假期看的。当时因为疫情封校，一字班的同学只能在学校度过长达五天的假期，未央-能动两个班组织了一系列活动，其中就包括了我作为文艺委员牵头组织的观影活动。<br>与平时观影感受不同，当自己作为放映者，看着大家沉浸在喜欢的影片中，也能感受到一种成就与满足。<br>那年五一夜晚紫荆操场坐满了人，大家在难得的放松时光宣泄着被压抑的情绪……<div style="text-align:center;"><img src="/img/集体观影.jpg" width="50%" height="50%"><img src="/img/五一.jpg" width="50%" height="50%"></div></li></ul><h3 id="10-风声"><a href="#10-风声" class="headerlink" title="10. 风声"></a>10. 风声</h3><p><img src="/img/%E9%A3%8E%E5%A3%B0.jpg" alt="风声"></p><ul><li>评分：9.6<br>一个人在西馆的319单间看完了这部电影，目前位置看过最出彩的谍战片。<br>风声之后，世间再无传奇。</li></ul><h3 id="11-头文字D"><a href="#11-头文字D" class="headerlink" title="11. 头文字D"></a>11. 头文字D</h3><p><img src="/img/%E5%A4%B4%E6%96%87%E5%AD%97D.jpg" alt="头文字D"></p><ul><li>评分：8.3<blockquote><p>我加速超越，却甩不掉紧紧跟随的伤悲<br>细数惭愧，我伤你几回<br>停止狼狈，就让错纯粹</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>电影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.31徐枫老师组会</title>
    <link href="/2023/08/31/8.31%E5%BE%90%E6%9E%AB%E8%80%81%E5%B8%88%E7%BB%84%E4%BC%9A/"/>
    <url>/2023/08/31/8.31%E5%BE%90%E6%9E%AB%E8%80%81%E5%B8%88%E7%BB%84%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="8-31徐枫老师组会"><a href="#8-31徐枫老师组会" class="headerlink" title="8.31徐枫老师组会"></a>8.31徐枫老师组会</h1><span id="more"></span><h2 id="1-人脸静态重建"><a href="#1-人脸静态重建" class="headerlink" title="1. 人脸静态重建"></a>1. 人脸静态重建</h2><ul><li>neus: Learning Neural Implicit Surfaces by Volume Rendering for Multi-view Reconstruction</li></ul><h2 id="2-逆渲染生成高质量渲染图片"><a href="#2-逆渲染生成高质量渲染图片" class="headerlink" title="2. 逆渲染生成高质量渲染图片"></a>2. 逆渲染生成高质量渲染图片</h2><ul><li>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</li><li>bumpy: adj.（旅程）颠簸的；不平的，多凸块的；经历困难，处境艰难</li><li>envmap:<br>“envmap” 是一个缩写，代表”environment map”（环境贴图）。环境贴图是计算机图形学中的一个重要概念，用于在虚拟场景中模拟真实世界的光照和反射效果，从而增强图像的逼真度。</li><li>detach: vt. 分离；使分开；派遣；使分心</li><li>artifact:<br>  在计算机图形学中，”artifact”（也称为”artefact”，中文译为”伪影”或”伪像”）是指在图像或渲染过程中出现的意外、不自然的图像元素或效果，通常是由于算法、处理步骤或技术限制导致的。这些意外效果可能影响图像的质量、真实感和逼真度。</li><li>Differentiable Rendering:<br>可导渲染（Differentiable Rendering）是一种将深度学习和计算机图形学技术结合的方法，允许通过反向传播技术对渲染过程进行微分，从而在渲染过程中计算梯度，用于优化任务，如图像生成、视觉效果增强和三维场景理解。</li><li>spp: Samples Per Pixel</li></ul><h2 id="3-实时Incremental人体重建"><a href="#3-实时Incremental人体重建" class="headerlink" title="3. 实时Incremental人体重建"></a>3. 实时Incremental人体重建</h2><ul><li>feature volume:<br>特征体（Feature Volume）是一种用于表示三维场景的数据结构，它将场景中的每个点映射到一个特征向量，该特征向量包含该点的特征信息，如颜色、法线、深度、光照等。特征体通常用于实时渲染和重建。</li></ul>]]></content>
    
    
    <categories>
      
      <category>组会笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_the-next-week</title>
    <link href="/2023/08/31/raytracing-the-next-week/"/>
    <url>/2023/08/31/raytracing-the-next-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-the-next-week"><a href="#raytracing-the-next-week" class="headerlink" title="raytracing the next week"></a>raytracing the next week</h1><span id="more"></span><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>add support for textures, volumes, rectangles, instances, lights, and for lots of objects using a BVH</li></ul><h2 id="2-Motion-Blur"><a href="#2-Motion-Blur" class="headerlink" title="2. Motion Blur"></a>2. Motion Blur</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>对于一个真实的相机，快门会保持打开一段时间，这段时间内，相机和世界中的物体可能会发生运动。</p><h3 id="2-1-Introduction-of-SpaceTime-Ray-Tracing"><a href="#2-1-Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="2.1 Introduction of SpaceTime Ray Tracing"></a>2.1 Introduction of SpaceTime Ray Tracing</h3><p>在相机快门打开的某一随机时刻，可以发出一条光线得到一个随机估计。只要我们可以确定在那个时刻物体的位置，我们就可以得到对于这条射线light的准确测量。<br>为了实现这个效果，我们需要存储每个ray的准确时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ray</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ray</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(<span class="hljs-number">0</span>) &#123;&#125; <br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction, <span class="hljs-type">double</span> time) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(time) &#123;&#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">origin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> orig; &#125;<br>    <span class="hljs-function">vec3 <span class="hljs-title">direction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dir; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">time</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123; <span class="hljs-keyword">return</span> tm; &#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orig + t*dir;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    point3 orig;<br>    vec3 dir;<br>    <span class="hljs-type">double</span> tm;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-Managing-Time"><a href="#2-2-Managing-Time" class="headerlink" title="2.2 Managing Time"></a>2.2 Managing Time</h3><p>目前只考虑渲染一帧图片，假设start at time&#x3D;0, end at time&#x3D;1。<br>任务有：</p><ol><li>调整相机使其能在time[0,1]之间随机时刻发出ray</li><li>创建一个可以移动的球体类</li></ol><h3 id="2-3-Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#2-3-Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="2.3 Updating the Camera to Simulate Motion Blur"></a>2.3 Updating the Camera to Simulate Motion Blur</h3><blockquote><p>make constructors complicated if it makes calls simple</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ray <span class="hljs-title">get_ray</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Get a randomly sampled camera ray for the pixel at location i,j.</span><br>    <span class="hljs-keyword">auto</span> pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);<br>    <span class="hljs-keyword">auto</span> pixel_sample = pixel_center + <span class="hljs-built_in">pixel_sample_square</span>();<br><br>    <span class="hljs-keyword">auto</span> ray_origin = (defocus_angle &lt;= <span class="hljs-number">0</span>) ? center : <span class="hljs-built_in">defocus_disk_sample</span>();<br>    <span class="hljs-keyword">auto</span> ray_direction = pixel_sample - ray_origin;<br>    <br>    <span class="hljs-keyword">auto</span> ray_time = <span class="hljs-built_in">random_double</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ray</span>(ray_origin, ray_direction, ray_time);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Adding-Moving-Spheres"><a href="#2-4-Adding-Moving-Spheres" class="headerlink" title="2.4 Adding Moving Spheres"></a>2.4 Adding Moving Spheres</h3><p>对于可运动的球，t&#x3D;0时球心位于center1，t&#x3D;1时球心位于center2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sphere</span> : <span class="hljs-keyword">public</span> hittable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//stationary</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-comment">//moving</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center1, point3 _center2, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center1), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            center_vec = _center2 - _center1;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        vec3 oc = r.<span class="hljs-built_in">origin</span>() - center1;<br>        <span class="hljs-keyword">auto</span> a = r.<span class="hljs-built_in">direction</span>().<span class="hljs-built_in">length_squared</span>();<br>        <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(oc, r.<span class="hljs-built_in">direction</span>());<br>        <span class="hljs-keyword">auto</span> c = oc.<span class="hljs-built_in">length_squared</span>() - radius * radius;<br><br>        <span class="hljs-keyword">auto</span> discriminant = half_b * half_b - a * c;<br>        <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>        <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>        <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>        &#123;<br>            root = (-half_b + sqrtd) / a;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        rec.t = root;<br>        rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>        vec3 outward_normal = (rec.p - center1) / radius;<br>        rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>        rec.mat = mat;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    point3 center1;<br>    <span class="hljs-type">double</span> radius;<br>    shared_ptr&lt;material&gt; mat;<br><br>    <span class="hljs-type">bool</span> is_moving;<br>    vec3 center_vec;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-type">double</span> time)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> center1 + time * center_vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在判断是否击中球体时，需要考虑球体的运动轨迹，即球心的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    point3 center = is_moving? <span class="hljs-built_in">sphere_center</span>(r.<span class="hljs-built_in">time</span>()) : center1;<br>    vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-Tracking-the-Time-of-Ray-Intersection"><a href="#2-5-Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="2.5 Tracking the Time of Ray Intersection"></a>2.5 Tracking the Time of Ray Intersection</h3><p>在计算散射ray时考虑时间属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lambertian</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> scatter_direction = rec.normal + <span class="hljs-built_in">random_unit_vector</span>();<br><br>        <span class="hljs-comment">// Catch degenerate scatter direction</span><br>        <span class="hljs-keyword">if</span> (scatter_direction.<span class="hljs-built_in">near_zero</span>())<br>            scatter_direction = rec.normal;<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">metal</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        vec3 reflected = <span class="hljs-built_in">reflect</span>(<span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>()), rec.normal);<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz*<span class="hljs-built_in">random_in_unit_sphere</span>(), r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dot</span>(scattered.<span class="hljs-built_in">direction</span>(), rec.normal) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dielectric</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, direction, r_in.<span class="hljs-built_in">time</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-6-Putting-Everything-Together"><a href="#2-6-Putting-Everything-Together" class="headerlink" title="2.6 Putting Everything Together"></a>2.6 Putting Everything Together</h3><p>给场景中的部分球体加入运动属性<br>效果图如下：<br><img src="/img/motion_blur.png" alt="motion_blur"></p><h2 id="3-Bounding-Volume-Hierarchies"><a href="#3-Bounding-Volume-Hierarchies" class="headerlink" title="3. Bounding Volume Hierarchies"></a>3. Bounding Volume Hierarchies</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>ray-object的求交是一个ray tracer最主要的时间瓶颈，我们可以按照二分查找的思想把这个过程变成对数时间的search。<br>我们可以对求交模型做一个模拟的sorting，这样每次求交可以变成一个sublinear的search。<br>常见的sorting方法有两种：1.分割空间 2.分割物体，后者在实现上更简单并且对于大多数模型来说速度一样快。</p><h3 id="3-1-The-Key-Idea"><a href="#3-1-The-Key-Idea" class="headerlink" title="3.1 The Key Idea"></a>3.1 The Key Idea</h3><p>包围盒的key idea是找到一个包围所有objects的volumes。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ray hit bounding object：<br>    <span class="hljs-keyword">return</span> 是否hit包围住的物体<br><span class="hljs-keyword">else</span>：<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>a key thing是我们可以把物体分为子集。<br>任何物体都只在一个包围盒中，但包围盒之间可以重叠。</p><h3 id="3-2-Hierarchies-of-Bounding-Volumes"><a href="#3-2-Hierarchies-of-Bounding-Volumes" class="headerlink" title="3.2 Hierarchies of Bounding Volumes"></a>3.2 Hierarchies of Bounding Volumes</h3><p><img src="/img/hierarchy.jpg" alt="hierarchy"><br>内部包围盒之间没有顺序，可能重叠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (hits purple)<br>    hit0 = hits blue enclosed objects<br>    hit1 = hits red enclosed objects<br>    <span class="hljs-keyword">if</span> (hit0 <span class="hljs-keyword">or</span> hit1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> info of closer hit<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="3-3-Axis-Aligned-Bounding-Boxes-AABBs"><a href="#3-3-Axis-Aligned-Bounding-Boxes-AABBs" class="headerlink" title="3.3 Axis-Aligned Bounding Boxes (AABBs)"></a>3.3 Axis-Aligned Bounding Boxes (AABBs)</h3><p>我们需要找到一种好的划分方式实践以上算法，axis-aligned bounding boxes(AABBs)是一种很好的选择。<br>$$\begin{align*}<br>    x_0 &#x3D; A_x + t_0b_x \newline<br>    t_0 &#x3D; \frac{x_0 - A_x}{b_x} \newline<br>    t_1 &#x3D; \frac{x_1 - A_x}{b_x}<br>\end{align*}$$<br><img src="/img/aabb.jpg" alt="aabb"><br>将上式转换为hit监测：如果hit则两个1D的t区间有交集。</p><h3 id="3-4-Ray-Intersection-with-an-AABB"><a href="#3-4-Ray-Intersection-with-an-AABB" class="headerlink" title="3.4 Ray Intersection with an AABB"></a>3.4 Ray Intersection with an AABB</h3><p>若使用IEEE浮点数，0有正负号。当$b_x&#x3D;0$时，若$A$不在$x_0,x_1$之间，则$t_{x0}, t_{x1}$将同时为$+\infty$或$-\infty$。<br>所以可以使用min和max得到正确的解<br>$$\begin{align*}<br>    t_{x0} &#x3D; min(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})\newline<br>    t_{x1} &#x3D; max(\frac{x_0 - A_x}{b_x}, \frac{x_1 - A_x}{b_x})<br>\end{align*}$$<br>在实现overlap函数时，如果有NaNs会报错，因此我们需要给包围盒加一点padding。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">interval</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> max - min;<br>    &#125;<br><br>    <span class="hljs-function">interval <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">double</span> delta)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> padding = delta/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">interval</span>(min - padding, max + padding);<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AABB_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AABB_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    interval x, y, z;<br><br>    <span class="hljs-built_in">aabb</span>() &#123;&#125; <span class="hljs-comment">// The default AABB is empty, since intervals are empty by default.</span><br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> interval&amp; ix, <span class="hljs-type">const</span> interval&amp; iy, <span class="hljs-type">const</span> interval&amp; iz)<br>      : <span class="hljs-built_in">x</span>(ix), <span class="hljs-built_in">y</span>(iy), <span class="hljs-built_in">z</span>(iz) &#123; &#125;<br><br>    <span class="hljs-built_in">aabb</span>(<span class="hljs-type">const</span> point3&amp; a, <span class="hljs-type">const</span> point3&amp; b) &#123;<br>        <span class="hljs-comment">// Treat the two points a and b as extrema for the bounding box, so we don&#x27;t require a</span><br>        <span class="hljs-comment">// particular minimum/maximum coordinate order.</span><br>        x = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]));<br>        y = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">1</span>],b[<span class="hljs-number">1</span>]));<br>        z = <span class="hljs-built_in">interval</span>(<span class="hljs-built_in">fmin</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]), <span class="hljs-built_in">fmax</span>(a[<span class="hljs-number">2</span>],b[<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> interval&amp; <span class="hljs-title">axis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> y;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> z;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> t0 = <span class="hljs-built_in">fmin</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-keyword">auto</span> t1 = <span class="hljs-built_in">fmax</span>((<span class="hljs-built_in">axis</span>(a).min - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a],<br>                           (<span class="hljs-built_in">axis</span>(a).max - r.<span class="hljs-built_in">origin</span>()[a]) / r.<span class="hljs-built_in">direction</span>()[a]);<br>            <span class="hljs-type">ray_t</span>.min = <span class="hljs-built_in">fmax</span>(t0, <span class="hljs-type">ray_t</span>.min);<br>            <span class="hljs-type">ray_t</span>.max = <span class="hljs-built_in">fmin</span>(t1, <span class="hljs-type">ray_t</span>.max);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-5-An-Optimized-AABB-Hit-Method"><a href="#3-5-An-Optimized-AABB-Hit-Method" class="headerlink" title="3.5 An Optimized AABB Hit Method"></a>3.5 An Optimized AABB Hit Method</h3><p>Andrew Kensler做了很多实验发现下面这个版本的代码在某些编译器上性能极好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">aabb</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">3</span>; a++) &#123;<br>            <span class="hljs-keyword">auto</span> invD = <span class="hljs-number">1</span> / r.<span class="hljs-built_in">direction</span>()[a];<br>            <span class="hljs-keyword">auto</span> orig = r.<span class="hljs-built_in">origin</span>()[a];<br><br>            <span class="hljs-keyword">auto</span> t0 = (<span class="hljs-built_in">axis</span>(a).min - orig) * invD;<br>            <span class="hljs-keyword">auto</span> t1 = (<span class="hljs-built_in">axis</span>(a).max - orig) * invD;<br><br>            <span class="hljs-keyword">if</span> (invD &lt; <span class="hljs-number">0</span>)<br>                std::<span class="hljs-built_in">swap</span>(t0, t1);<br><br>            <span class="hljs-keyword">if</span> (t0 &gt; <span class="hljs-type">ray_t</span>.min) <span class="hljs-type">ray_t</span>.min = t0;<br>            <span class="hljs-keyword">if</span> (t1 &lt; <span class="hljs-type">ray_t</span>.max) <span class="hljs-type">ray_t</span>.max = t1;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">ray_t</span>.max &lt;= <span class="hljs-type">ray_t</span>.min)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-6-Constructing-Bounding-Boxes-for-Hittables"><a href="#3-6-Constructing-Bounding-Boxes-for-Hittables" class="headerlink" title="3.6 Constructing Bounding Boxes for Hittables"></a>3.6 Constructing Bounding Boxes for Hittables</h3><p>为objects添加包围盒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于静止球体，可以直接根据center和radius计算；对于运动球体，可以根据radius和center1，center2分别计算两个包围盒，再求这两个包围盒的并集。</p><h3 id="3-7-Creating-Bounding-Boxes-of-Lists-of-Objects"><a href="#3-7-Creating-Bounding-Boxes-of-Lists-of-Objects" class="headerlink" title="3.7 Creating Bounding Boxes of Lists of Objects"></a>3.7 Creating Bounding Boxes of Lists of Objects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aabb.h&quot;</span></span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hittable_list</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;<br><br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123;<br>        objects.<span class="hljs-built_in">push_back</span>(object);<br>        bbox = <span class="hljs-built_in">aabb</span>(bbox, object-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, <span class="hljs-type">double</span> ray_tmin, <span class="hljs-type">double</span> ray_tmax, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    aabb bbox;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-8-The-BVH-Node-Class"><a href="#3-8-The-BVH-Node-Class" class="headerlink" title="3.8 The BVH Node Class"></a>3.8 The BVH Node Class</h3><p>A BVH是一个容器，like lists of hittables，可以respond to “whether hit” query<br>一种设计思路是划分两个类，分别为node和tree；一种是将root视为node，每次对node的包围盒进行hit判断，如果hit则对node的两个子节点进行hit判断。本书采用后者实现思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BVH_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BVH_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hittable_list.h&quot;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> hittable_list&amp; list) : <span class="hljs-built_in">bvh_node</span>(list.objects, <span class="hljs-number">0</span>, list.objects.<span class="hljs-built_in">size</span>()) &#123;&#125;<br><br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-comment">// To be implemented later.</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r, interval <span class="hljs-type">ray_t</span>, hit_record&amp; rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!box.<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">bool</span> hit_left = left-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-type">ray_t</span>, rec);<br>        <span class="hljs-type">bool</span> hit_right = right-&gt;<span class="hljs-built_in">hit</span>(r, <span class="hljs-built_in">interval</span>(<span class="hljs-type">ray_t</span>.min, hit_left ? rec.t : <span class="hljs-type">ray_t</span>.max), rec);<br><br>        <span class="hljs-keyword">return</span> hit_left || hit_right;<br>    &#125;<br><br>    <span class="hljs-function">aabb <span class="hljs-title">bounding_box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> bbox; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;hittable&gt; left;<br>    shared_ptr&lt;hittable&gt; right;<br>    aabb bbox;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="3-9-Splitting-BVH-Volumes"><a href="#3-9-Splitting-BVH-Volumes" class="headerlink" title="3.9 Splitting BVH Volumes"></a>3.9 Splitting BVH Volumes</h3><blockquote><p>The most complicated part of any efficiency structure, including the BVH, is building it.The most complicated part of any efficiency structure, including the BVH, is building it.</p></blockquote><p>build一个BVH的过程如下：</p><ol><li>randomly choose an axis</li><li>sort the primitives (using std::sort)</li><li>put half in each subtree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-built_in">bvh_node</span>(<span class="hljs-type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end) &#123;<br>        <span class="hljs-keyword">auto</span> objects = src_objects; <span class="hljs-comment">// Create a modifiable array of the source scene objects</span><br><br>        <span class="hljs-type">int</span> axis = <span class="hljs-built_in">random_int</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">auto</span> comparator = (axis == <span class="hljs-number">0</span>) ? box_x_compare<br>                        : (axis == <span class="hljs-number">1</span>) ? box_y_compare<br>                                      : box_z_compare;<br><br>        <span class="hljs-type">size_t</span> object_span = end - start;<br><br>        <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">1</span>) &#123;<br>            left = right = objects[start];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object_span == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">comparator</span>(objects[start], objects[start+<span class="hljs-number">1</span>])) &#123;<br>                left = objects[start];<br>                right = objects[start+<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = objects[start+<span class="hljs-number">1</span>];<br>                right = objects[start];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>() + start, objects.<span class="hljs-built_in">begin</span>() + end, comparator);<br><br>            <span class="hljs-keyword">auto</span> mid = start + object_span/<span class="hljs-number">2</span>;<br>            left = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid);<br>            right = <span class="hljs-built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end);<br>        &#125;<br><br>        bbox = <span class="hljs-built_in">aabb</span>(left-&gt;<span class="hljs-built_in">bounding_box</span>(), right-&gt;<span class="hljs-built_in">bounding_box</span>());<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>当objects中有无限大平面时需要检查是否有包围盒，因为无限大平面无包围盒。</li></ol><h3 id="3-10-The-Box-Comparison-Functions"><a href="#3-10-The-Box-Comparison-Functions" class="headerlink" title="3.10 The Box Comparison Functions"></a>3.10 The Box Comparison Functions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bvh_node</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  ...<br>  <span class="hljs-keyword">private</span>:<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_compare</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b, <span class="hljs-type">int</span> axis_index</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min &lt; b-&gt;<span class="hljs-built_in">bounding_box</span>().<span class="hljs-built_in">axis</span>(axis_index).min;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_x_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_y_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">box_z_compare</span> <span class="hljs-params">(<span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; a, <span class="hljs-type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">box_compare</span>(a, b, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>经测试，渲染下图无包围盒层次结构所用时间为67.4132s，有包围盒层次结构所用时间为17.7801s。<br><img src="/img/motion_blur.png" alt="image"></p><h2 id="4-Texture-Mapping"><a href="#4-Texture-Mapping" class="headerlink" title="4.Texture Mapping"></a>4.Texture Mapping</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><ul><li>texture: the effect(color, shininess, bump geometry, …)</li><li>mapping: mapping one space onto another in the mathematical sense</li></ul><h3 id="4-1-Constant-Color-Texture"><a href="#4-1-Constant-Color-Texture" class="headerlink" title="4.1 Constant Color Texture"></a>4.1 Constant Color Texture</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TEXTURE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEXTURE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">texture</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">texture</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3 &amp;p)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">solid_color</span> : <span class="hljs-keyword">public</span> texture<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">solid_color</span>(color c) : <span class="hljs-built_in">color_value</span>(c) &#123;&#125;<br><br>    <span class="hljs-built_in">solid_color</span>(<span class="hljs-type">double</span> red, <span class="hljs-type">double</span> green, <span class="hljs-type">double</span> blue) : <span class="hljs-built_in">solid_color</span>(<span class="hljs-built_in">color</span>(red, green, blue)) &#123;&#125;<br><br>    <span class="hljs-function">color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3 &amp;p)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> color_value;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    color color_value;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>同时在hittable类中增加double变量u,v</p><h3 id="4-2-Solid-Textures-A-Checker-Texture"><a href="#4-2-Solid-Textures-A-Checker-Texture" class="headerlink" title="4.2 Solid Textures: A Checker Texture"></a>4.2 Solid Textures: A Checker Texture</h3><p>solid texture仅取决于3D空间中每个点的位置，它给空间中所有点上色，而不是特定的物体。<br>the texture value忽略u,v，只取决于p。<br>对于给定的点，我们可以通过floor函数得到$x, y, z$的整数部分，然后求和模2判断奇偶性。<br>同时可以增加一个scale参数，使得方格纹理的大小可以调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">checker_texture</span> : <span class="hljs-keyword">public</span> texture &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">checker_texture</span>(<span class="hljs-type">double</span> _scale, shared_ptr&lt;texture&gt; _even, shared_ptr&lt;texture&gt; _odd)<br>      : <span class="hljs-built_in">inv_scale</span>(<span class="hljs-number">1.0</span> / _scale), <span class="hljs-built_in">even</span>(_even), <span class="hljs-built_in">odd</span>(_odd) &#123;&#125;<br><br>    <span class="hljs-built_in">checker_texture</span>(<span class="hljs-type">double</span> _scale, color c1, color c2)<br>      : <span class="hljs-built_in">inv_scale</span>(<span class="hljs-number">1.0</span> / _scale),<br>        <span class="hljs-built_in">even</span>(<span class="hljs-built_in">make_shared</span>&lt;solid_color&gt;(c1)),<br>        <span class="hljs-built_in">odd</span>(<span class="hljs-built_in">make_shared</span>&lt;solid_color&gt;(c2))<br>    &#123;&#125;<br><br>    <span class="hljs-function">color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3&amp; p)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> xInteger = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">floor</span>(inv_scale * p.<span class="hljs-built_in">x</span>()));<br>        <span class="hljs-keyword">auto</span> yInteger = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">floor</span>(inv_scale * p.<span class="hljs-built_in">y</span>()));<br>        <span class="hljs-keyword">auto</span> zInteger = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">floor</span>(inv_scale * p.<span class="hljs-built_in">z</span>()));<br><br>        <span class="hljs-type">bool</span> isEven = (xInteger + yInteger + zInteger) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> isEven ? even-&gt;<span class="hljs-built_in">value</span>(u, v, p) : odd-&gt;<span class="hljs-built_in">value</span>(u, v, p);<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> inv_scale;<br>    shared_ptr&lt;texture&gt; even;<br>    shared_ptr&lt;texture&gt; odd;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-3-Rendering-The-Solid-Checker-Texture"><a href="#4-3-Rendering-The-Solid-Checker-Texture" class="headerlink" title="4.3 Rendering The Solid Checker Texture"></a>4.3 Rendering The Solid Checker Texture</h3><p>项目需要支持渲染不同的场景，一个简单的方法是在main函数中用switch控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-number">2</span>)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">random_spheres</span>();<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">two_spheres</span>();<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续可以用别的方法，比如命令行参数等。<br>渲染得到的两个格子纹理球体图片如下：<br><img src="/img/checker.png" alt="image"><br>可以发现结果有点odd，因为checker_texture是一个空间纹理，我们观察到的是球体的表面在切割三维空间。</p><h3 id="4-4-Texture-Coordinates-for-Spheres"><a href="#4-4-Texture-Coordinates-for-Spheres" class="headerlink" title="4.4 Texture Coordinates for Spheres"></a>4.4 Texture Coordinates for Spheres</h3><p>首先计算球体坐标系下的$(\theta, \phi)$<br>$\theta$: up from -Y<br>$\phi$: from -X -&gt; +Z -&gt; +X -&gt; -Z -&gt; -X<br>然后根据$(\theta, \phi)$计算纹理坐标$(u, v)$<br>$$\begin{align*}<br>    u &#x3D; \frac{\phi}{2\pi} \newline<br>    v &#x3D; \frac{\theta}{\pi}<br>\end{align*}$$<br>转化为Cartesian坐标系：<br>$$\begin{align*}<br>    x &#x3D; -\sin(\theta)\cos(\phi) \newline<br>    y &#x3D; -\cos(\theta) \newline<br>    z &#x3D; \sin(\theta)\sin(\phi)<br>\end{align*}$$<br>使用atan2()函数可以得到：<br>$$\begin{align*}<br>    \phi &#x3D; \arctan2(z, -x)<br>\end{align*}$$<br>atan2()返回值顺序为：0-&gt;$\pi$，再-$\pi$-&gt;0<br>由于<br>$$\begin{align*}<br>    atan2(a, b) &#x3D; atan2(-a, -b) + \pi<br>\end{align*}$$<br>所以可以先做翻转再做加$\pi$操作。<br>$$\begin{align*}<br>    \phi &#x3D; \arctan2(-z, x) + \pi<br>\end{align*}$$<br>然后求解$\theta$：<br>$$\begin{align*}<br>    \theta &#x3D; \arccos(-y)<br>\end{align*}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sphere</span> : <span class="hljs-keyword">public</span> hittable &#123;<br>  ...<br>  <span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">get_sphere_uv</span><span class="hljs-params">(<span class="hljs-type">const</span> point3&amp; p, <span class="hljs-type">double</span>&amp; u, <span class="hljs-type">double</span>&amp; v)</span> </span>&#123;<br>        <span class="hljs-comment">// p: a given point on the sphere of radius one, centered at the origin.</span><br>        <span class="hljs-comment">// u: returned value [0,1] of angle around the Y axis from X=-1.</span><br>        <span class="hljs-comment">// v: returned value [0,1] of angle from Y=-1 to Y=+1.</span><br>        <span class="hljs-comment">//     &lt;1 0 0&gt; yields &lt;0.50 0.50&gt;       &lt;-1  0  0&gt; yields &lt;0.00 0.50&gt;</span><br>        <span class="hljs-comment">//     &lt;0 1 0&gt; yields &lt;0.50 1.00&gt;       &lt; 0 -1  0&gt; yields &lt;0.50 0.00&gt;</span><br>        <span class="hljs-comment">//     &lt;0 0 1&gt; yields &lt;0.25 0.50&gt;       &lt; 0  0 -1&gt; yields &lt;0.75 0.50&gt;</span><br><br>        <span class="hljs-keyword">auto</span> theta = <span class="hljs-built_in">acos</span>(-p.<span class="hljs-built_in">y</span>());<br>        <span class="hljs-keyword">auto</span> phi = <span class="hljs-built_in">atan2</span>(-p.<span class="hljs-built_in">z</span>(), p.<span class="hljs-built_in">x</span>()) + pi;<br><br>        u = phi / (<span class="hljs-number">2</span>*pi);<br>        v = theta / pi;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种计算方法为根据像素坐标(i, j):<br>$$\begin{align*}<br>    u &#x3D; \frac{i}{width - 1} \newline<br>    v &#x3D; \frac{j}{height - 1}<br>\end{align*}$$</p><h3 id="4-5-Accessing-Texture-Image-Data"><a href="#4-5-Accessing-Texture-Image-Data" class="headerlink" title="4.5 Accessing Texture Image Data"></a>4.5 Accessing Texture Image Data</h3><p>使用图像工具库stb_image.h</p><blockquote><p>It reads image data into a big array of unsigned chars. These are just packed RGBs with each component in the range [0,255] (black to full white)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtweekend.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rtw_stb_image.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;perlin.h&quot;</span></span><br><br>...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">image_texture</span> : <span class="hljs-keyword">public</span> texture &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">image_texture</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename) : <span class="hljs-built_in">image</span>(filename) &#123;&#125;<br><br>    <span class="hljs-function">color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3&amp; p)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// If we have no texture data, then return solid cyan as a debugging aid.</span><br>        <span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">height</span>() &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// Clamp input texture coordinates to [0,1] x [1,0]</span><br>        u = <span class="hljs-built_in">interval</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>).<span class="hljs-built_in">clamp</span>(u);<br>        v = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">interval</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>).<span class="hljs-built_in">clamp</span>(v);  <span class="hljs-comment">// Flip V to image coordinates</span><br><br>        <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(u * image.<span class="hljs-built_in">width</span>());<br>        <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(v * image.<span class="hljs-built_in">height</span>());<br>        <span class="hljs-keyword">auto</span> pixel = image.<span class="hljs-built_in">pixel_data</span>(i,j);<br><br>        <span class="hljs-keyword">auto</span> color_scale = <span class="hljs-number">1.0</span> / <span class="hljs-number">255.0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(color_scale*pixel[<span class="hljs-number">0</span>], color_scale*pixel[<span class="hljs-number">1</span>], color_scale*pixel[<span class="hljs-number">2</span>]);<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    rtw_image image;<br>&#125;;<br></code></pre></td></tr></table></figure><p>原始(u,v)的坐标系x轴向右，y轴向上，而图像坐标系x轴向右，y轴向下，所以需要对v进行翻转。</p><h3 id="4-6-Rendering-The-Image-Texture"><a href="#4-6-Rendering-The-Image-Texture" class="headerlink" title="4.6 Rendering The Image Texture"></a>4.6 Rendering The Image Texture</h3><p><img src="/img/earth.png" alt="image"></p><h2 id="5-Perlin-Noise"><a href="#5-Perlin-Noise" class="headerlink" title="5. Perlin Noise"></a>5. Perlin Noise</h2><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><p><img src="/img/perlin.jpg" alt="image"></p><blockquote><p>It takes a 3D point as input and always returns the same randomish number. Nearby points return similar numbers</p></blockquote><p>关于noise的详细介绍可以参考我的另一篇博客<a href="https://blog.csdn.net/qq_41971087/article/details/118811796">PBRT-Noise</a></p><h3 id="5-1-Using-Blocks-of-Random-Numbers"><a href="#5-1-Using-Blocks-of-Random-Numbers" class="headerlink" title="5.1 Using Blocks of Random Numbers"></a>5.1 Using Blocks of Random Numbers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ranfloat: a big array of random doubles</span><br><span class="hljs-comment">// perm_x, perm_y, perm_z: arrays of random integers</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">noise</span><span class="hljs-params">(<span class="hljs-type">const</span> point3&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>*p.<span class="hljs-built_in">x</span>()) &amp; <span class="hljs-number">255</span>;<br>    <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>*p.<span class="hljs-built_in">y</span>()) &amp; <span class="hljs-number">255</span>;<br>    <span class="hljs-keyword">auto</span> k = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>*p.<span class="hljs-built_in">z</span>()) &amp; <span class="hljs-number">255</span>;<br><br>    <span class="hljs-keyword">return</span> ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];<br>&#125;<br></code></pre></td></tr></table></figure><p>这种组合查找方式可以产生连续和平滑的噪声效果。 </p><h3 id="5-2-Smoothing-out-the-Result"><a href="#5-2-Smoothing-out-the-Result" class="headerlink" title="5.2 Smoothing out the Result"></a>5.2 Smoothing out the Result</h3><p>要使结果平滑，可以采用线性插值的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">perlin</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">noise</span><span class="hljs-params">(<span class="hljs-type">const</span> point3&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> u = p.<span class="hljs-built_in">x</span>() - <span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">x</span>());<br>        <span class="hljs-keyword">auto</span> v = p.<span class="hljs-built_in">y</span>() - <span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">y</span>());<br>        <span class="hljs-keyword">auto</span> w = p.<span class="hljs-built_in">z</span>() - <span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">z</span>());<br><br>        <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">x</span>()));<br>        <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">y</span>()));<br>        <span class="hljs-keyword">auto</span> k = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">floor</span>(p.<span class="hljs-built_in">z</span>()));<br>        <span class="hljs-type">double</span> c[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> di=<span class="hljs-number">0</span>; di &lt; <span class="hljs-number">2</span>; di++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dj=<span class="hljs-number">0</span>; dj &lt; <span class="hljs-number">2</span>; dj++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dk=<span class="hljs-number">0</span>; dk &lt; <span class="hljs-number">2</span>; dk++)<br>                    c[di][dj][dk] = ranfloat[<br>                        perm_x[(i+di) &amp; <span class="hljs-number">255</span>] ^<br>                        perm_y[(j+dj) &amp; <span class="hljs-number">255</span>] ^<br>                        perm_z[(k+dk) &amp; <span class="hljs-number">255</span>]<br>                    ];<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">trilinear_interp</span>(c, u, v, w);<br>    &#125;<br>    ...<br><br>  <span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">trilinear_interp</span><span class="hljs-params">(<span class="hljs-type">double</span> c[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">double</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> accum = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)<br>                    accum += (i*u + (<span class="hljs-number">1</span>-i)*(<span class="hljs-number">1</span>-u))*<br>                            (j*v + (<span class="hljs-number">1</span>-j)*(<span class="hljs-number">1</span>-v))*<br>                            (k*w + (<span class="hljs-number">1</span>-k)*(<span class="hljs-number">1</span>-w))*c[i][j][k];<br><br>        <span class="hljs-keyword">return</span> accum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/img/smoothing.png" alt="smoothing"></p><h3 id="5-3-Improvement-with-Hermitian-Smoothing"><a href="#5-3-Improvement-with-Hermitian-Smoothing" class="headerlink" title="5.3 Improvement with Hermitian Smoothing"></a>5.3 Improvement with Hermitian Smoothing</h3><p>smoothing后的结果有明显的网格特征，有部分是Mach bands, a known perceptual artifact of linear interpolation of color.</p><blockquote><p>Mach bands is an optical illusion named after the physicist Ernst Mach. It exaggerates the contrast between edges of the slightly differing shades of gray, as soon as they contact one another, by triggering edge-detection in the human visual system.</p></blockquote><p><img src="/img/mach.gif" alt="mach bands"><br>一个标准的技巧是使用Hermite cubic使插值更平滑。</p><blockquote><p>Hermite cubic 是一种数学插值方法，通常用于在给定一些数据点的情况下生成一个平滑的曲线或曲面。这个方法使用 Hermite 插值多项式来逼近数据点之间的曲线，以便在这些点之间获得连续和平滑的函数或曲线。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">perlin</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">public</span>:</span></span><br><span class="hljs-params"><span class="hljs-function">    ...</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> noise(<span class="hljs-type">const</span> point3&amp; p) <span class="hljs-type">const</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> u = p.x() - floor(p.x());</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> v = p.y() - floor(p.y());</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> w = p.z() - floor(p.z());</span></span><br><span class="hljs-params"><span class="hljs-function">        u = u*u*(<span class="hljs-number">3</span><span class="hljs-number">-2</span>*u);</span></span><br><span class="hljs-params"><span class="hljs-function">        v = v*v*(<span class="hljs-number">3</span><span class="hljs-number">-2</span>*v);</span></span><br><span class="hljs-params"><span class="hljs-function">        w = w*w*(<span class="hljs-number">3</span><span class="hljs-number">-2</span>*w);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> i = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(floor(p.x()));</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> j = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(floor(p.y()));</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> k = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(floor(p.z()));</span></span><br><span class="hljs-params"><span class="hljs-function">        ...</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/hermite.png" alt="hermite"></p><h3 id="5-4-Tweaking-The-Frequency"><a href="#5-4-Tweaking-The-Frequency" class="headerlink" title="5.4 Tweaking The Frequency"></a>5.4 Tweaking The Frequency</h3><p>目前的频率有点低，我们可以控制输入scale来调整频率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">noise_texture</span> : <span class="hljs-keyword">public</span> texture &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">noise_texture</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">noise_texture</span>(<span class="hljs-type">double</span> sc) : <span class="hljs-built_in">scale</span>(sc) &#123;&#125;<br><br>    <span class="hljs-function">color <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">double</span> u, <span class="hljs-type">double</span> v, <span class="hljs-type">const</span> point3&amp; p)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">color</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) * noise.<span class="hljs-built_in">noise</span>(scale * p);<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    perlin noise;<br>    <span class="hljs-type">double</span> scale;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/img/scale.png" alt="frequency"></p><h3 id="5-5-Using-Random-Vectors-on-the-Lattice-Points"><a href="#5-5-Using-Random-Vectors-on-the-Lattice-Points" class="headerlink" title="5.5 Using Random Vectors on the Lattice Points"></a>5.5 Using Random Vectors on the Lattice Points</h3><p><img src="/img/random.png" alt="image"></p><h3 id="5-6-Introducing-Turbulence"><a href="#5-6-Introducing-Turbulence" class="headerlink" title="5.6 Introducing Turbulence"></a>5.6 Introducing Turbulence</h3><p><img src="/img/turb.png" alt="image"></p><h3 id="5-7-Adjusting-the-Phase"><a href="#5-7-Adjusting-the-Phase" class="headerlink" title="5.7 Adjusting the Phase"></a>5.7 Adjusting the Phase</h3><p><img src="/img/marbled.png" alt="image"></p><h2 id="6-Quadrilaterals"><a href="#6-Quadrilaterals" class="headerlink" title="6. Quadrilaterals"></a>6. Quadrilaterals</h2>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_in-one-week</title>
    <link href="/2023/08/30/raytracing-in-one-week/"/>
    <url>/2023/08/30/raytracing-in-one-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-in-one-week"><a href="#raytracing-in-one-week" class="headerlink" title="raytracing in one week"></a>raytracing in one week</h1><span id="more"></span><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h2><p>笔者在大二下学期上了《计算机图形学基础》这门课，由于时间匆忙+能力有限，在完成光线追踪渲染器时疏漏了很多细节。关于真实感渲染器的实现有很多不错的课程资料，比如Games101，smallpt，Ray Tracing in One Weekend等等，笔者计划在大三上学期开学前抽出一周时间，完成Ray Tracing in One Weekend的学习，以此来巩固自己的图形学基础知识，实现一个质量更高的光线追踪渲染器。</p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>get cool images with no API</li><li>the architecture will be good for extending to a more full-featured ray tracer</li></ul><h2 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2. Output an Image"></a>2. Output an Image</h2>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
