<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>raytracing_the-next-week</title>
    <link href="/2023/08/31/raytracing-the-next-week/"/>
    <url>/2023/08/31/raytracing-the-next-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-the-next-week"><a href="#raytracing-the-next-week" class="headerlink" title="raytracing the next week"></a>raytracing the next week</h1><span id="more"></span><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>add support for textures, volumes, rectangles, instances, lights, and for lots of objects using a BVH</li></ul><h2 id="2-Motion-Blur"><a href="#2-Motion-Blur" class="headerlink" title="2. Motion Blur"></a>2. Motion Blur</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>对于一个真实的相机，快门会保持打开一段时间，这段时间内，相机和世界中的物体可能会发生运动。</p><h3 id="2-1-Introduction-of-SpaceTime-Ray-Tracing"><a href="#2-1-Introduction-of-SpaceTime-Ray-Tracing" class="headerlink" title="2.1 Introduction of SpaceTime Ray Tracing"></a>2.1 Introduction of SpaceTime Ray Tracing</h3><p>在相机快门打开的某一随机时刻，可以发出一条光线得到一个随机估计。只要我们可以确定在那个时刻物体的位置，我们就可以得到对于这条射线light的准确测量。<br>为了实现这个效果，我们需要存储每个ray的准确时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ray</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ray</span>() &#123;&#125;<br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(<span class="hljs-number">0</span>) &#123;&#125; <br><br>    <span class="hljs-built_in">ray</span>(<span class="hljs-type">const</span> point3&amp; origin, <span class="hljs-type">const</span> vec3&amp; direction, <span class="hljs-type">double</span> time) : <span class="hljs-built_in">orig</span>(origin), <span class="hljs-built_in">dir</span>(direction), <span class="hljs-built_in">tm</span>(time) &#123;&#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">origin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> orig; &#125;<br>    <span class="hljs-function">vec3 <span class="hljs-title">direction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dir; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">time</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123; <span class="hljs-keyword">return</span> tm; &#125;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orig + t*dir;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    point3 orig;<br>    vec3 dir;<br>    <span class="hljs-type">double</span> tm;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-Managing-Time"><a href="#2-2-Managing-Time" class="headerlink" title="2.2 Managing Time"></a>2.2 Managing Time</h3><p>目前只考虑渲染一帧图片，假设start at time&#x3D;0, end at time&#x3D;1。<br>任务有：</p><ol><li>调整相机使其能在time[0,1]之间随机时刻发出ray</li><li>创建一个可以移动的球体类</li></ol><h3 id="2-3-Updating-the-Camera-to-Simulate-Motion-Blur"><a href="#2-3-Updating-the-Camera-to-Simulate-Motion-Blur" class="headerlink" title="2.3 Updating the Camera to Simulate Motion Blur"></a>2.3 Updating the Camera to Simulate Motion Blur</h3><blockquote><p>make constructors complicated if it makes calls simple</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ray <span class="hljs-title">get_ray</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Get a randomly sampled camera ray for the pixel at location i,j.</span><br>    <span class="hljs-keyword">auto</span> pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);<br>    <span class="hljs-keyword">auto</span> pixel_sample = pixel_center + <span class="hljs-built_in">pixel_sample_square</span>();<br><br>    <span class="hljs-keyword">auto</span> ray_origin = (defocus_angle &lt;= <span class="hljs-number">0</span>) ? center : <span class="hljs-built_in">defocus_disk_sample</span>();<br>    <span class="hljs-keyword">auto</span> ray_direction = pixel_sample - ray_origin;<br>    <br>    <span class="hljs-keyword">auto</span> ray_time = <span class="hljs-built_in">random_double</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ray</span>(ray_origin, ray_direction, ray_time);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Adding-Moving-Spheres"><a href="#2-4-Adding-Moving-Spheres" class="headerlink" title="2.4 Adding Moving Spheres"></a>2.4 Adding Moving Spheres</h3><p>对于可运动的球，t&#x3D;0时球心位于center1，t&#x3D;1时球心位于center2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sphere</span> : <span class="hljs-keyword">public</span> hittable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//stationary</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-comment">//moving</span><br>    <span class="hljs-built_in">sphere</span>(point3 _center1, point3 _center2, <span class="hljs-type">double</span> _radius, shared_ptr&lt;material&gt; _mat)<br>        : <span class="hljs-built_in">center1</span>(_center1), <span class="hljs-built_in">radius</span>(_radius), <span class="hljs-built_in">mat</span>(_mat), <span class="hljs-built_in">is_moving</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            center_vec = _center2 - _center1;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        vec3 oc = r.<span class="hljs-built_in">origin</span>() - center1;<br>        <span class="hljs-keyword">auto</span> a = r.<span class="hljs-built_in">direction</span>().<span class="hljs-built_in">length_squared</span>();<br>        <span class="hljs-keyword">auto</span> half_b = <span class="hljs-built_in">dot</span>(oc, r.<span class="hljs-built_in">direction</span>());<br>        <span class="hljs-keyword">auto</span> c = oc.<span class="hljs-built_in">length_squared</span>() - radius * radius;<br><br>        <span class="hljs-keyword">auto</span> discriminant = half_b * half_b - a * c;<br>        <span class="hljs-keyword">if</span> (discriminant &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> sqrtd = <span class="hljs-built_in">sqrt</span>(discriminant);<br><br>        <span class="hljs-comment">// Find the nearest root that lies in the acceptable range.</span><br>        <span class="hljs-keyword">auto</span> root = (-half_b - sqrtd) / a;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>        &#123;<br>            root = (-half_b + sqrtd) / a;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-type">ray_t</span>.<span class="hljs-built_in">surrounds</span>(root))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        rec.t = root;<br>        rec.p = r.<span class="hljs-built_in">at</span>(rec.t);<br>        vec3 outward_normal = (rec.p - center1) / radius;<br>        rec.<span class="hljs-built_in">set_face_normal</span>(r, outward_normal);<br>        rec.mat = mat;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    point3 center1;<br>    <span class="hljs-type">double</span> radius;<br>    shared_ptr&lt;material&gt; mat;<br><br>    <span class="hljs-type">bool</span> is_moving;<br>    vec3 center_vec;<br><br>    <span class="hljs-function">point3 <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-type">double</span> time)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> center1 + time * center_vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在判断是否击中球体时，需要考虑球体的运动轨迹，即球心的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hit</span><span class="hljs-params">(<span class="hljs-type">const</span> ray &amp;r, interval <span class="hljs-type">ray_t</span>, hit_record &amp;rec)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    point3 center = is_moving? <span class="hljs-built_in">sphere_center</span>(r.<span class="hljs-built_in">time</span>()) : center1;<br>    vec3 oc = r.<span class="hljs-built_in">origin</span>() - center;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-Tracking-the-Time-of-Ray-Intersection"><a href="#2-5-Tracking-the-Time-of-Ray-Intersection" class="headerlink" title="2.5 Tracking the Time of Ray Intersection"></a>2.5 Tracking the Time of Ray Intersection</h3><p>在计算散射ray时考虑时间属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lambertian</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> scatter_direction = rec.normal + <span class="hljs-built_in">random_unit_vector</span>();<br><br>        <span class="hljs-comment">// Catch degenerate scatter direction</span><br>        <span class="hljs-keyword">if</span> (scatter_direction.<span class="hljs-built_in">near_zero</span>())<br>            scatter_direction = rec.normal;<br><br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">metal</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        vec3 reflected = <span class="hljs-built_in">reflect</span>(<span class="hljs-built_in">unit_vector</span>(r_in.<span class="hljs-built_in">direction</span>()), rec.normal);<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, reflected + fuzz*<span class="hljs-built_in">random_in_unit_sphere</span>(), r_in.<span class="hljs-built_in">time</span>());<br>        attenuation = albedo;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dot</span>(scattered.<span class="hljs-built_in">direction</span>(), rec.normal) &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dielectric</span> : <span class="hljs-keyword">public</span> material &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">scatter</span><span class="hljs-params">(<span class="hljs-type">const</span> ray&amp; r_in, <span class="hljs-type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered)</span></span><br><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ...<br>        scattered = <span class="hljs-built_in">ray</span>(rec.p, direction, r_in.<span class="hljs-built_in">time</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-6-Putting-Everything-Together"><a href="#2-6-Putting-Everything-Together" class="headerlink" title="2.6 Putting Everything Together"></a>2.6 Putting Everything Together</h3><p>给场景中的部分球体加入运动属性<br>效果图如下：<br><img src="/img/motion_blur.png" alt="motion_blur"></p>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raytracing_in-one-week</title>
    <link href="/2023/08/30/raytracing-in-one-week/"/>
    <url>/2023/08/30/raytracing-in-one-week/</url>
    
    <content type="html"><![CDATA[<h1 id="raytracing-in-one-week"><a href="#raytracing-in-one-week" class="headerlink" title="raytracing in one week"></a>raytracing in one week</h1><span id="more"></span><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h2><p>笔者在大二下学期上了《计算机图形学基础》这门课，由于时间匆忙+能力有限，在完成光线追踪渲染器时疏漏了很多细节。关于真实感渲染器的实现有很多不错的课程资料，比如Games101，smallpt，Ray Tracing in One Weekend等等，笔者计划在大三上学期开学前抽出一周时间，完成Ray Tracing in One Weekend的学习，以此来巩固自己的图形学基础知识，实现一个质量更高的光线追踪渲染器。</p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><ul><li>get cool images with no API</li><li>the architecture will be good for extending to a more full-featured ray tracer</li></ul><h2 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2. Output an Image"></a>2. Output an Image</h2>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
